<!DOCTYPE html>
<html lang="en" class=""> <!-- Add/remove 'dark' class here to toggle theme -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Snake Whiteboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        #whiteboard {
            cursor: grab;
            touch-action: none;
        }
        .dropdown-content {
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
            transform-origin: top;
        }
        #note-editor, #noteBoxInput {
            font-family: 'Inter', sans-serif;
            resize: none;
        }
        .modal-panel {
             transition: opacity 0.2s ease-out, transform 0.2s ease-out;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Style for dark mode */
        .dark body {
            background-color: #111827; /* gray-900 */
        }
        .dark #controls, .dark #noteBox {
            background-color: rgba(31, 41, 55, 0.8); /* bg-gray-800/80 */
            border-color: #374151; /* border-gray-700 */
        }
        .dark h2, .dark h3, .dark button, .dark .text-gray-700 {
            color: #D1D5DB; /* gray-300 */
        }
        .dark #userInfo {
            background-color: #374151; /* gray-700 */
            color: #9CA3AF; /* gray-400 */
        }
        .dark .snake-menu button {
            background-color: #374151; /* gray-700 */
            color: #E5E7EB; /* gray-200 */
        }
         .dark .snake-menu button:hover {
            background-color: #4B5563; /* gray-600 */
         }
        .dark .dropdown-content {
            background-color: #1F2937; /* gray-800 */
            border-color: #374151; /* gray-700 */
        }
        .dark .dropdown-content button:hover {
            background-color: #374151; /* gray-700 */
        }
         .dark .text-sky-700 { color: #7DD3FC; /* sky-300 */ }
         .dark .hover\:bg-sky-50:hover { background-color: rgba(56, 189, 248, 0.1); }
         .dark .text-red-700 { color: #FCA5A5; /* red-300 */ }
         .dark .hover\:bg-red-50:hover { background-color: rgba(239, 68, 68, 0.1); }
         .dark #noteBoxInput {
            background-color: #374151; /* gray-700 */
            color: #E5E7EB; /* gray-200 */
            border-color: #4B5563; /* gray-600 */
         }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col items-center justify-center p-4 bg-gray-100 dark:bg-gray-900">

    <div class="w-full h-full bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 relative overflow-hidden">
        
        <div class="absolute top-4 left-4 z-20 flex flex-col space-y-2 max-h-[90vh]">
            <div id="controls" class="p-4 bg-white/80 backdrop-blur-sm rounded-lg shadow border border-gray-200 flex flex-col space-y-2 overflow-y-auto">
                <h2 class="font-bold text-gray-700 text-lg">Controls</h2>
                <div id="userInfo" class="text-xs text-gray-500 bg-gray-100 p-2 rounded-md break-all">Connecting...</div>
                <button id="createSnakeBtn" class="w-full px-4 py-2 bg-blue-500 text-white font-semibold rounded-md hover:bg-blue-600 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">Create Snake</button>
                <button id="addPointBtn" class="w-full px-4 py-2 bg-green-500 text-white font-semibold rounded-md hover:bg-green-600 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75 cursor-grab">Add Point</button>
                <button id="toggleThemeBtn" class="w-full px-4 py-2 bg-indigo-500 text-white font-semibold rounded-md hover:bg-indigo-600 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75">Toggle Theme</button>
                <button id="clearBoardBtn" class="w-full px-4 py-2 bg-red-500 text-white font-semibold rounded-md hover:bg-red-600 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-red-400 focus:ring-opacity-75">Clear Board</button>
                
                <div id="snakeControlsContainer" class="flex flex-col space-y-2"></div>
            </div>
            <div id="noteBox" class="p-4 bg-white/80 backdrop-blur-sm rounded-lg shadow border border-gray-200 flex flex-col space-y-2">
                <h3 class="font-bold text-gray-700 text-lg">Note Box</h3>
                <textarea id="noteBoxInput" class="w-full h-24 p-2 border rounded-md bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="Type shared notes here..."></textarea>
            </div>
        </div>

        <canvas id="whiteboard"></canvas>

    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, onSnapshot, addDoc, updateDoc, deleteDoc, writeBatch, getDocs, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- SETUP ---
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const parentContainer = canvas.parentElement;

        // --- UI ELEMENTS ---
        const createSnakeBtn = document.getElementById('createSnakeBtn');
        const clearBoardBtn = document.getElementById('clearBoardBtn');
        const toggleThemeBtn = document.getElementById('toggleThemeBtn');
        const snakeControlsContainer = document.getElementById('snakeControlsContainer');
        const userInfoDiv = document.getElementById('userInfo');
        const noteBoxInput = document.getElementById('noteBoxInput');
        const addPointBtn = document.getElementById('addPointBtn');
        
        // --- GLOBAL & FIRESTORE STATE ---
        let db, auth;
        let snakesCollection, pointsCollection, notesCollection, noteBoxDocRef;
        
        // Local state, populated by Firestore
        let snakes = []; 
        let points = []; 
        let notes = [];

        // --- INTERACTION STATE ---
        let isDraggingPoint = false, isDraggingSnake = false, isResizingNote = false, isDraggingNote = false, isPanning = false;
        let draggedPoint = null, draggedSnake = null, resizedNote = null, draggedNote = null, selectedPoint = null;
        let potentialDrag = null, mouseDownCoords = null, panStart = { x: 0, y: 0 };
        let draggingNewPointState = { active: false, x: 0, y: 0, dropTarget: null };


        // Viewport state for panning and zooming
        let view = { x: 0, y: 0, zoom: 1 };
        
        // --- THEME & COLORS ---
        const LIGHT_THEME = {
            background: '#FFFFFF', head: '#10B981', body: '#FFFFFF', tail: '#EF4444',
            line: '#374151', noteBg: '#FEF9C3', noteBorder: '#FDE047', link: '#0000EE', text: '#1F2937',
            selection: '#007BFF', lineHighlight: '#0EA5E9'
        };
        const DARK_THEME = {
            background: '#1F2937', head: '#34D399', body: '#FFFFFF', tail: '#F87171',
            line: '#9CA3AF', noteBg: '#4B5563', noteBorder: '#6B7280', link: '#60A5FA', text: '#F3F4F6',
            selection: '#00AFFF', lineHighlight: '#38BDF8'
        };
        let COLORS = LIGHT_THEME;
        let currentTheme = 'light';

        // --- CONSTANTS ---
        const POINT_RADIUS = 12;
        const STRETCH_LIMIT = 300; 
        const LABEL_FONT = 'bold 16px Inter';
        const LABEL_HEIGHT = 16;
        const NOTE_FONT = '14px Inter';
        const MIN_NOTE_WIDTH = 80;
        const MIN_NOTE_HEIGHT = 40;
        const MIN_ZOOM = 0.2;
        const MAX_ZOOM = 5;
        const DRAG_THRESHOLD = 4;
        const LINE_HIT_WIDTH = 10;

        // --- UTILITY & COORDINATE FUNCTIONS ---
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        function isValidUrl(string) {
            try {
                const url = new URL(string);
                return url.protocol === "http:" || url.protocol === "https:";
            } catch (_) { return false; }
        }

        function screenToWorld(screenX, screenY) {
            return { x: (screenX / view.zoom) + view.x, y: (screenY / view.zoom) + view.y };
        }

        function worldToScreen(worldX, worldY) {
            return { x: (worldX - view.x) * view.zoom, y: (worldY - view.y) * view.zoom };
        }

        // --- CLASSES ---
        class Point {
            constructor(x, y, type) {
                this.id = null; this.x = x; this.y = y; this.type = type;
                this.originalX = 0; this.originalY = 0;
            }
            draw(angle = 0) {
                if (this.type === 'head') {
                    ctx.save();
                    ctx.translate(this.x, this.y); ctx.rotate(angle);
                    ctx.fillStyle = COLORS.head;
                    ctx.beginPath(); ctx.ellipse(0, 0, POINT_RADIUS * 1.2, POINT_RADIUS * 0.9, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.beginPath(); ctx.arc(POINT_RADIUS * 0.5, -POINT_RADIUS * 0.4, 2, 0, Math.PI * 2); ctx.arc(POINT_RADIUS * 0.5, POINT_RADIUS * 0.4, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath(); ctx.arc(POINT_RADIUS * 0.6, -POINT_RADIUS * 0.4, 1, 0, Math.PI * 2); ctx.arc(POINT_RADIUS * 0.6, POINT_RADIUS * 0.4, 1, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                } else if (this.type === 'tail') {
                    ctx.fillStyle = COLORS.tail;
                    ctx.beginPath(); ctx.moveTo(this.x, this.y + POINT_RADIUS); ctx.lineTo(this.x - POINT_RADIUS, this.y - POINT_RADIUS / 2); ctx.lineTo(this.x + POINT_RADIUS, this.y - POINT_RADIUS / 2); ctx.closePath(); ctx.fill();
                } else {
                    ctx.beginPath(); ctx.arc(this.x, this.y, POINT_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = this.type === 'body' ? COLORS.body : COLORS[this.type];
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2; ctx.stroke();
                }
            }
            isClicked(mouseX, mouseY) {
                return Math.hypot(mouseX - this.x, mouseY - this.y) < POINT_RADIUS * 1.2;
            }
        }

        class Note {
            constructor(text, attachedPointId) {
                this.id = null; this.text = text; this.attachedPointId = attachedPointId;
                this.width = 160; this.height = 100; this.originalWidth = 0; this.originalHeight = 0;
                this.offsetX = 40; this.offsetY = -50; this.originalOffsetX = 0; this.originalOffsetY = 0;
            }
            wrapText(context, text, x, y, maxWidth, lineHeight) {
                const words = text.split(' '); let line = '';
                context.font = NOTE_FONT; context.textAlign = 'left'; context.textBaseline = 'top';
                for(let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = context.measureText(testLine);
                    if (metrics.width > maxWidth && n > 0) {
                        context.fillText(line, x, y); line = words[n] + ' '; y += lineHeight;
                    } else { line = testLine; }
                }
                context.fillText(line, x, y);
            }
            draw(parentPoint) {
                const noteX = parentPoint.x + this.offsetX, noteY = parentPoint.y + this.offsetY;
                ctx.beginPath(); ctx.moveTo(parentPoint.x, parentPoint.y); ctx.lineTo(noteX, noteY + this.height / 2);
                ctx.strokeStyle = '#9CA3AF'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = COLORS.noteBg; ctx.strokeStyle = COLORS.noteBorder; ctx.lineWidth = 1.5;
                ctx.fillRect(noteX, noteY, this.width, this.height); ctx.strokeRect(noteX, noteY, this.width, this.height);
                const isLink = isValidUrl(this.text);
                ctx.fillStyle = isLink ? COLORS.link : COLORS.text;
                this.wrapText(ctx, this.text, noteX + 8, noteY + 8, this.width - 24, 18);
                const deleteIconX = noteX + this.width - 10, deleteIconY = noteY + 10, iconSize = 6;
                ctx.beginPath(); ctx.moveTo(deleteIconX - iconSize, deleteIconY - iconSize); ctx.lineTo(deleteIconX + iconSize, deleteIconY + iconSize);
                ctx.moveTo(deleteIconX + iconSize, deleteIconY - iconSize); ctx.lineTo(deleteIconX - iconSize, deleteIconY + iconSize);
                ctx.strokeStyle = '#6B7280'; ctx.lineWidth = 2; ctx.stroke();
                if (isLink) {
                    const linkIconX = noteX + this.width - 12, linkIconY = noteY + this.height - 12;
                    ctx.strokeStyle = COLORS.link; ctx.lineWidth = 1.5; ctx.strokeRect(linkIconX, linkIconY, 6, 6);
                    ctx.beginPath(); ctx.moveTo(linkIconX + 3, linkIconY); ctx.lineTo(linkIconX + 9, linkIconY - 6);
                    ctx.moveTo(linkIconX + 4, linkIconY - 6); ctx.lineTo(linkIconX + 9, linkIconY - 6); ctx.lineTo(linkIconX + 9, linkIconY - 1); ctx.stroke();
                }
                const resizeHandleX = noteX + this.width, resizeHandleY = noteY + this.height;
                ctx.fillStyle = '#9CA3AF';
                ctx.beginPath(); ctx.moveTo(resizeHandleX, resizeHandleY - 10); ctx.lineTo(resizeHandleX - 10, resizeHandleY); ctx.lineTo(resizeHandleX, resizeHandleY); ctx.closePath(); ctx.fill();
            }
            isBodyClicked(mouseX, mouseY, p) { const nX = p.x + this.offsetX, nY = p.y + this.offsetY; return mouseX > nX && mouseX < nX + this.width && mouseY > nY && mouseY < nY + this.height; }
            isDeleteClicked(mouseX, mouseY, p) { const nX = p.x + this.offsetX, nY = p.y + this.offsetY, dX = nX + this.width - 10, dY = nY + 10, hA = 10; return mouseX > dX - hA && mouseX < dX + hA && mouseY > dY - hA && mouseY < dY + hA; }
            isLinkIconClicked(mouseX, mouseY, p) { const nX = p.x + this.offsetX, nY = p.y + this.offsetY, lX = nX + this.width - 12, lY = nY + this.height - 12, hA = 12; return mouseX > lX - hA && mouseX < lX + hA && mouseY > lY - hA && mouseY < lY + hA; }
            isResizeClicked(mouseX, mouseY, p) { const nX = p.x + this.offsetX, nY = p.y + this.offsetY, rX = nX + this.width, rY = nY + this.height, hA = 15; return mouseX > rX - hA && mouseX < rX + hA && mouseY > rY - hA && mouseY < rY + hA; }
        }
        
        // --- CORE DRAWING FUNCTIONS ---
        function resizeCanvas() { canvas.width = parentContainer.clientWidth; canvas.height = parentContainer.clientHeight; draw(); }

        function draw() {
            if (!ctx) return;
            ctx.save();
            ctx.fillStyle = COLORS.background; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.translate(canvas.width / 2, canvas.height / 2); ctx.scale(view.zoom, view.zoom);
            ctx.translate(-canvas.width / 2, -canvas.height / 2); ctx.translate(-view.x, -view.y);
            
            // Highlight drop target line
            if (draggingNewPointState.active && draggingNewPointState.dropTarget) {
                const { snake, segmentIndex } = draggingNewPointState.dropTarget;
                const p1 = snake.path[segmentIndex];
                const p2 = snake.path[segmentIndex + 1];
                if(p1 && p2) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.strokeStyle = COLORS.lineHighlight;
                    ctx.lineWidth = 8;
                    ctx.stroke();
                }
            }

            snakes.forEach(s => {
                if (s.path && s.path.length > 1) {
                    ctx.beginPath(); ctx.moveTo(s.path[0].x, s.path[0].y);
                    for (let i = 1; i < s.path.length; i++) { ctx.lineTo(s.path[i].x, s.path[i].y); }
                    ctx.strokeStyle = s.color || COLORS.line;
                    ctx.lineWidth = 4; ctx.stroke();
                }
            });
            notes.forEach(n => { const p = points.find(pt => pt.id === n.attachedPointId); if (p) n.draw(p); });
            points.forEach(p => {
                let angle = 0;
                const owner = snakes.find(s => s.path && s.path.some(sp => sp.id === p.id));
                if (p.type === 'head' && owner && owner.path.length > 1) { angle = Math.atan2(owner.path[1].y - p.y, owner.path[1].x - p.x); }
                p.draw(angle);
            });
            snakes.forEach(s => {
                if (s.path && s.path.length > 0) {
                    const head = s.path[0];
                    ctx.fillStyle = COLORS.text; ctx.font = LABEL_FONT; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.fillText(s.name, head.x, head.y - POINT_RADIUS - 5);
                }
            });
            if (selectedPoint) {
                ctx.strokeStyle = COLORS.selection; ctx.lineWidth = 3 / view.zoom;
                ctx.beginPath(); ctx.arc(selectedPoint.x, selectedPoint.y, POINT_RADIUS * 1.5, 0, Math.PI * 2); ctx.stroke();
            }

            // Draw the point being dragged from the UI
            if (draggingNewPointState.active) {
                ctx.beginPath();
                ctx.arc(draggingNewPointState.x, draggingNewPointState.y, POINT_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = draggingNewPointState.dropTarget ? '#22C55E' : 'rgba(0,0,0,0.5)'; // Green if snappable
                ctx.fill();
            }

            ctx.restore();
        }

        function getPointAt(worldX, worldY) {
            for (let i = points.length - 1; i >= 0; i--) { if (points[i].isClicked(worldX, worldY)) return points[i]; }
            return null;
        }

        function findClosestLineSegment(worldX, worldY) {
            let closest = { dist: Infinity, snake: null, segmentIndex: -1, point: null };

            for (const snake of snakes) {
                if (!snake.path || snake.path.length < 2) continue;
                for (let i = 0; i < snake.path.length - 1; i++) {
                    const p1 = snake.path[i];
                    const p2 = snake.path[i + 1];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const lenSq = dx * dx + dy * dy;

                    let t = ((worldX - p1.x) * dx + (worldY - p1.y) * dy) / lenSq;
                    t = Math.max(0, Math.min(1, t)); // Clamp to segment

                    const closestPoint = { x: p1.x + t * dx, y: p1.y + t * dy };
                    const distSq = (worldX - closestPoint.x) ** 2 + (worldY - closestPoint.y) ** 2;

                    if (distSq < closest.dist) {
                        closest = { dist: distSq, snake: snake, segmentIndex: i, point: closestPoint };
                    }
                }
            }

            if (closest.dist < (LINE_HIT_WIDTH / view.zoom)**2) {
                return closest;
            }
            return null;
        }


        // --- EVENT HANDLERS ---
        function handleMouseDown(e) {
            e.preventDefault(); potentialDrag = null; if (e.button !== 0) return;
            const worldCoords = screenToWorld(e.offsetX, e.offsetY); mouseDownCoords = worldCoords;
            for (let i = notes.length - 1; i >= 0; i--) {
                const note = notes[i], p = points.find(pt => pt.id === note.attachedPointId);
                if (p) {
                    if (note.isDeleteClicked(worldCoords.x, worldCoords.y, p)) { deleteDoc(doc(notesCollection, note.id)); mouseDownCoords = null; return; }
                    if (note.isResizeClicked(worldCoords.x, worldCoords.y, p)) { potentialDrag = { type: 'note-resize', target: note }; note.originalWidth = note.width; note.originalHeight = note.height; canvas.style.cursor = 'nwse-resize'; return; }
                    if (isValidUrl(note.text) && note.isLinkIconClicked(worldCoords.x, worldCoords.y, p)) { window.open(note.text, '_blank'); mouseDownCoords = null; return; }
                    if (note.isBodyClicked(worldCoords.x, worldCoords.y, p)) { potentialDrag = { type: 'note-drag', target: note }; note.originalOffsetX = note.offsetX; note.originalOffsetY = note.offsetY; canvas.style.cursor = 'grabbing'; return; }
                }
            }
            const clickedPoint = getPointAt(worldCoords.x, worldCoords.y);
            if (clickedPoint) { potentialDrag = { type: 'point', target: clickedPoint }; canvas.style.cursor = 'grabbing'; return; }
            for (let i = snakes.length - 1; i >= 0; i--) {
                const snake = snakes[i]; if (!snake.path || snake.path.length === 0) continue;
                const head = snake.path[0]; ctx.font = LABEL_FONT; const metrics = ctx.measureText(snake.name);
                const labelX = head.x - metrics.width / 2, labelY = head.y - POINT_RADIUS - 5 - LABEL_HEIGHT;
                if (worldCoords.x > labelX && worldCoords.x < labelX + metrics.width && worldCoords.y > labelY && worldCoords.y < labelY + LABEL_HEIGHT) {
                    potentialDrag = { type: 'snake-drag', target: snake }; snake.path.forEach(p => { p.originalX = p.x; p.originalY = p.y; }); canvas.style.cursor = 'move'; return;
                }
            }
            if (selectedPoint) { selectedPoint = null; draw(); }
            potentialDrag = { type: 'pan' }; panStart = { x: e.clientX, y: e.clientY }; canvas.style.cursor = 'grabbing';
        }
        
        function handleMouseMove(e) {
            e.preventDefault();
            const activeDrag = isDraggingPoint || isDraggingSnake || isResizingNote || isDraggingNote || isPanning;
            if (activeDrag) {
                const worldCoords = screenToWorld(e.offsetX, e.offsetY);
                if (isPanning) { const dx = e.clientX - panStart.x, dy = e.clientY - panStart.y; view.x -= dx / view.zoom; view.y -= dy / view.zoom; panStart = { x: e.clientX, y: e.clientY }; }
                else if (isResizingNote && resizedNote) { const dX = worldCoords.x - mouseDownCoords.x, dY = worldCoords.y - mouseDownCoords.y; resizedNote.width = Math.max(MIN_NOTE_WIDTH, resizedNote.originalWidth + dX); resizedNote.height = Math.max(MIN_NOTE_HEIGHT, resizedNote.originalHeight + dY); }
                else if (isDraggingNote && draggedNote) { const dX = worldCoords.x - mouseDownCoords.x, dY = worldCoords.y - mouseDownCoords.y; draggedNote.offsetX = draggedNote.originalOffsetX + dX; draggedNote.offsetY = draggedNote.originalOffsetY + dY; }
                else if (isDraggingPoint && draggedPoint) {
                    let cX = worldCoords.x, cY = worldCoords.y;
                    const owner = snakes.find(s => s.path && s.path.some(p => p.id === draggedPoint.id));
                    if (owner) {
                        const idx = owner.path.findIndex(p => p.id === draggedPoint.id), prev = owner.path[idx - 1], next = owner.path[idx + 1];
                        if (prev) { const d = Math.hypot(cX - prev.x, cY - prev.y); if (d > STRETCH_LIMIT) { const a = Math.atan2(cY - prev.y, cX - prev.x); cX = prev.x + STRETCH_LIMIT * Math.cos(a); cY = prev.y + STRETCH_LIMIT * Math.sin(a); } }
                        if (next) { const d = Math.hypot(cX - next.x, cY - next.y); if (d > STRETCH_LIMIT) { const a = Math.atan2(cY - next.y, cX - next.x); cX = next.x + STRETCH_LIMIT * Math.cos(a); cY = next.y + STRETCH_LIMIT * Math.sin(a); } }
                    }
                    draggedPoint.x = cX; draggedPoint.y = cY;
                } else if (isDraggingSnake && draggedSnake) { const dX = worldCoords.x - mouseDownCoords.x, dY = worldCoords.y - mouseDownCoords.y; draggedSnake.path.forEach(p => { p.x = p.originalX + dX; p.y = p.originalY + dY; }); }
                draw(); return;
            }
            if (potentialDrag && mouseDownCoords) {
                const dist = Math.hypot(screenToWorld(e.offsetX, e.offsetY).x - mouseDownCoords.x, screenToWorld(e.offsetX, e.offsetY).y - mouseDownCoords.y);
                if (dist > DRAG_THRESHOLD) {
                    switch (potentialDrag.type) {
                        case 'point': isDraggingPoint = true; draggedPoint = potentialDrag.target; break;
                        case 'note-resize': isResizingNote = true; resizedNote = potentialDrag.target; break;
                        case 'note-drag': isDraggingNote = true; draggedNote = potentialDrag.target; break;
                        case 'snake-drag': isDraggingSnake = true; draggedSnake = potentialDrag.target; break;
                        case 'pan': isPanning = true; break;
                    }
                    potentialDrag = null;
                }
            }
        }

        function handleMouseUp(e) {
            e.preventDefault();
            const wasClick = !isDraggingPoint && !isDraggingSnake && !isResizingNote && !isDraggingNote && !isPanning;
            if (wasClick && potentialDrag) {
                selectedPoint = potentialDrag.type === 'point' ? potentialDrag.target : null;
                draw();
            }
            if (isDraggingPoint && draggedPoint) { updateDoc(doc(pointsCollection, draggedPoint.id), { x: draggedPoint.x, y: draggedPoint.y }); }
            if (isDraggingSnake && draggedSnake) { const b = writeBatch(db); draggedSnake.path.forEach(p => { b.update(doc(pointsCollection, p.id), { x: p.x, y: p.y }); }); b.commit(); }
            if (isResizingNote && resizedNote) { updateDoc(doc(notesCollection, resizedNote.id), { width: resizedNote.width, height: resizedNote.height }); }
            if (isDraggingNote && draggedNote) { updateDoc(doc(notesCollection, draggedNote.id), { offsetX: draggedNote.offsetX, offsetY: draggedNote.offsetY }); }
            isDraggingPoint = isDraggingSnake = isResizingNote = isPanning = isDraggingNote = false;
            draggedPoint = draggedSnake = resizedNote = draggedNote = null;
            potentialDrag = null; mouseDownCoords = null; canvas.style.cursor = 'grab';
        }

        async function handleContextMenu(e) {
            e.preventDefault();
            const worldCoords = screenToWorld(e.offsetX, e.offsetY);
            const clickedPoint = getPointAt(worldCoords.x, worldCoords.y);
            if(clickedPoint) {
                const existingNote = notes.find(n => n.attachedPointId === clickedPoint.id);
                if(existingNote){ createNoteInput(existingNote); }
                else {
                    const newNoteData = { text: "Type something...", attachedPointId: clickedPoint.id, width: 160, height: 100, offsetX: 40, offsetY: -50 };
                    try {
                        await addDoc(notesCollection, newNoteData);
                    } catch (error) { console.error("Error creating note:", error); }
                }
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const mousePos = { x: e.offsetX, y: e.offsetY };
            const worldPosBeforeZoom = screenToWorld(mousePos.x, mousePos.y);
            let newZoom = view.zoom * (e.deltaY < 0 ? 1.1 : 1/1.1);
            view.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
            const worldPosAfterZoom = screenToWorld(mousePos.x, mousePos.y);
            view.x += worldPosBeforeZoom.x - worldPosAfterZoom.x;
            view.y += worldPosBeforeZoom.y - worldPosAfterZoom.y;
            draw();
        }
        
        function handleDoubleClick(e) {
            e.preventDefault(); if (e.target !== canvas) return;
            const worldCoords = screenToWorld(e.offsetX, e.offsetY);
            for (let i = notes.length - 1; i >= 0; i--) {
                const note = notes[i], p = points.find(pt => pt.id === note.attachedPointId);
                if (p && note.isBodyClicked(worldCoords.x, worldCoords.y, p)) { createNoteInput(note); return; }
            }
        }

        async function removeBodyPoint(pointToRemove) {
            if (!pointToRemove || pointToRemove.type !== 'body') return;
            const ownerSnake = snakes.find(s => s.path && s.path.some(p => p.id === pointToRemove.id));
            if (!ownerSnake) { console.warn("Could not find owner snake for point", pointToRemove.id); await deleteDoc(doc(pointsCollection, pointToRemove.id)); return; }
            const newPathArray = ownerSnake.path.map(p => p.id).filter(id => id !== pointToRemove.id);
            if (newPathArray.length < 2) { console.log("Cannot remove point, snake must have at least 2 points."); return; } // Path needs at least head and tail
            const batch = writeBatch(db);
            batch.update(doc(snakesCollection, ownerSnake.id), { path: newPathArray });
            batch.delete(doc(pointsCollection, pointToRemove.id));
            const noteToDelete = notes.find(n => n.attachedPointId === pointToRemove.id);
            if (noteToDelete) { batch.delete(doc(notesCollection, noteToDelete.id)); }
            try { await batch.commit(); selectedPoint = null; } catch (error) { console.error("Error removing body point:", error); }
        }

        async function removeBranchSnakes(branchSnakes) {
            const batch = writeBatch(db);
            for (const snake of branchSnakes) {
                batch.delete(doc(snakesCollection, snake.id));
                const pointsToDelete = snake.path.slice(1);
                for (const point of pointsToDelete) {
                    batch.delete(doc(pointsCollection, point.id));
                    const noteToDelete = notes.find(n => n.attachedPointId === point.id);
                    if (noteToDelete) { batch.delete(doc(notesCollection, noteToDelete.id)); }
                }
            }
            try { await batch.commit(); selectedPoint = null; } 
            catch (error) { console.error("Error removing branches:", error); }
        }

        async function branchFromPoint(branchingPoint) {
            if (!branchingPoint || branchingPoint.type !== 'body') return;
            const ownerSnake = snakes.find(s => s.path && s.path.some(p => p.id === branchingPoint.id));
            let newSnakeName = 'New Branch';
            if (ownerSnake) {
                const branchCount = snakes.filter(s => s.path && s.path[0]?.id === branchingPoint.id).length;
                newSnakeName = `${ownerSnake.name.replace(/\s/g, '')} b${branchCount + 1}`;
            }

            const batch = writeBatch(db);
            const newBodyData = { x: branchingPoint.x + 50, y: branchingPoint.y + 50, type: 'body' };
            const newTailData = { x: branchingPoint.x + 50, y: branchingPoint.y + 150, type: 'tail' };
            const newBodyRef = doc(collection(db, pointsCollection.path));
            const newTailRef = doc(collection(db, pointsCollection.path));
            batch.set(newBodyRef, newBodyData);
            batch.set(newTailRef, newTailData);
            const newSnakeData = {
                name: newSnakeName,
                path: [branchingPoint.id, newBodyRef.id, newTailRef.id],
                color: '#FBBF24' // A nice yellow color
            };
            const newSnakeRef = doc(collection(db, snakesCollection.path));
            batch.set(newSnakeRef, newSnakeData);
            try { await batch.commit(); selectedPoint = null; } 
            catch (error) { console.error("Error creating new branch:", error); }
        }

        async function handleKeyDown(e) {
            if (['TEXTAREA', 'INPUT'].includes(document.activeElement.tagName) || !selectedPoint) return;

            if (e.key === 'Backspace' || e.key === 'Delete') {
                e.preventDefault();
                const branches = snakes.filter(s => s.path[0]?.id === selectedPoint.id);
                if (branches.length > 0) {
                    showConfirmationModal(
                        "This is a junction point. Are you sure you want to delete the entire branch originating from here?",
                        () => removeBranchSnakes(branches),
                        "Yes, Delete Branch"
                    );
                } else {
                    await removeBodyPoint(selectedPoint);
                }
            } else if (e.key === 'k') {
                e.preventDefault();
                await branchFromPoint(selectedPoint);
            }
        }

        // --- UI/CONTROL LOGIC ---
        function toggleTheme() {
            if (currentTheme === 'light') { currentTheme = 'dark'; COLORS = DARK_THEME; document.documentElement.classList.add('dark'); }
            else { currentTheme = 'light'; COLORS = LIGHT_THEME; document.documentElement.classList.remove('dark'); }
            draw();
        }

        function showConfirmationModal(message, onConfirm, confirmText = 'Confirm') {
            document.getElementById('confirmation-modal-overlay')?.remove();
            const overlay = document.createElement('div');
            overlay.id = 'confirmation-modal-overlay';
            overlay.className = 'fixed inset-0 bg-black/60 z-40 flex items-center justify-center p-4';
            const panel = document.createElement('div');
            panel.className = 'modal-panel bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm transform opacity-0 translate-y-4';
            const text = document.createElement('p');
            text.className = 'text-gray-800 dark:text-gray-200 mb-6 text-lg';
            text.textContent = message;
            const btnContainer = document.createElement('div');
            btnContainer.className = 'flex justify-end space-x-3';
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'px-5 py-2 bg-gray-200 dark:bg-gray-600 dark:text-gray-200 text-gray-800 font-semibold rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400';
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = confirmText;
            confirmBtn.className = 'px-5 py-2 bg-red-500 text-white font-semibold rounded-md hover:bg-red-600 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400';
            btnContainer.append(cancelBtn, confirmBtn);
            panel.append(text, btnContainer);
            overlay.appendChild(panel);
            document.body.appendChild(overlay);
            setTimeout(() => { panel.classList.remove('opacity-0', 'translate-y-4'); panel.classList.add('opacity-100', 'translate-y-0'); }, 10);
            const closeModal = () => { panel.classList.add('opacity-0'); setTimeout(() => overlay.remove(), 200); };
            cancelBtn.addEventListener('click', closeModal);
            confirmBtn.addEventListener('click', () => { onConfirm(); closeModal(); });
            overlay.addEventListener('click', (e) => { if (e.target === overlay) closeModal(); });
        }

        function createNoteInput(note) {
            document.getElementById('note-editor')?.remove();
            const parentPoint = points.find(p => p.id === note.attachedPointId); if (!parentPoint) return;
            const screenPos = worldToScreen(parentPoint.x + note.offsetX, parentPoint.y + note.offsetY);
            const screenWidth = note.width * view.zoom, screenHeight = note.height * view.zoom;
            const textarea = document.createElement('textarea');
            textarea.id = 'note-editor'; textarea.value = note.text === "Type something..." ? "" : note.text;
            textarea.style.position = 'absolute'; textarea.style.left = `${canvas.offsetLeft + screenPos.x}px`;
            textarea.style.top = `${canvas.offsetTop + screenPos.y}px`; textarea.style.width = `${screenWidth}px`;
            textarea.style.height = `${screenHeight}px`; textarea.style.zIndex = '30';
            textarea.className = 'p-2 border-2 border-blue-500 rounded-md shadow-lg focus:outline-none bg-yellow-50 dark:bg-yellow-900/80 dark:text-white';
            parentContainer.appendChild(textarea); textarea.focus(); textarea.select();
            const finishEditing = () => {
                if(document.body.contains(textarea)) {
                    const newText = textarea.value.trim() === '' ? 'Type something...' : textarea.value;
                    if (note.text !== newText) { updateDoc(doc(notesCollection, note.id), { text: newText }); }
                    parentContainer.removeChild(textarea);
                }
            };
            textarea.addEventListener('blur', finishEditing);
            textarea.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); finishEditing(); } else if (e.key === 'Escape') { finishEditing(); } });
        }

        function showRenameInput(menuContainer) {
            const snakeId = menuContainer.dataset.id, snake = snakes.find(s => s.id === snakeId);
            const toggleButton = menuContainer.querySelector('button'), dropdownContent = menuContainer.querySelector('.dropdown-content');
            dropdownContent.classList.add('hidden'); toggleButton.style.display = 'none';
            const input = document.createElement('input'); input.type = 'text'; input.value = snake.name;
            input.className = 'w-full px-3 py-2 bg-white dark:bg-gray-600 border border-blue-400 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400';
            menuContainer.insertBefore(input, toggleButton); input.focus(); input.select();
            const finishRename = () => {
                const newName = input.value.trim();
                if (newName && newName !== snake.name) { updateDoc(doc(snakesCollection, snakeId), { name: newName }); }
                menuContainer.removeChild(input); toggleButton.style.display = 'block';
            };
            input.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === 'Escape') finishRename(); });
            input.addEventListener('blur', finishRename);
        }

        function createSnakeDropdownMenu(snake) {
            const menuContainer = document.createElement('div'); menuContainer.className = 'relative snake-menu'; menuContainer.dataset.id = snake.id;
            const toggleButton = document.createElement('button'); toggleButton.innerHTML = `${snake.name} Actions <span class="text-xs">▼</span>`;
            toggleButton.className = 'w-full text-left px-3 py-2 bg-gray-200 text-gray-800 font-semibold rounded-md hover:bg-gray-300 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-gray-400';
            const dropdownContent = document.createElement('div'); dropdownContent.className = 'dropdown-content absolute left-0 right-0 mt-1 bg-white border rounded-md shadow-lg p-2 space-y-1 hidden z-10';
            dropdownContent.innerHTML = `<button data-action="rename" class="w-full text-left px-3 py-1.5 text-sm text-gray-700 hover:bg-gray-100 rounded-md">Rename</button><div class="border-t my-1 dark:border-gray-600"></div><button data-action="remove" class="w-full text-left px-3 py-1.5 text-sm text-red-700 hover:bg-red-50 rounded-md">Remove Snake</button>`;
            menuContainer.append(toggleButton, dropdownContent); snakeControlsContainer.appendChild(menuContainer);
        }

        snakeControlsContainer.addEventListener('click', e => {
            const button = e.target.closest('button'); if (!button) return;
            const menuContainer = e.target.closest('.snake-menu'); if (!menuContainer) return;
            if (button === menuContainer.querySelector('button')) { menuContainer.querySelector('.dropdown-content').classList.toggle('hidden'); return; }
            const action = button.dataset.action;
            if (action) {
                const snakeId = menuContainer.dataset.id;
                if (action === 'rename') showRenameInput(menuContainer);
                else if (action === 'remove') removeSnake(snakeId);
            }
        });

        createSnakeBtn.addEventListener('click', async () => {
            const batch = writeBatch(db);
            const startX = view.x + (canvas.width / 2 / view.zoom), startY = view.y + (canvas.height / 2 / view.zoom);
            const headData = { x: startX, y: startY - 100, type: 'head' }, bodyData = { x: startX, y: startY, type: 'body' }, tailData = { x: startX, y: startY + 100, type: 'tail' };
            const headRef = doc(collection(db, pointsCollection.path)), bodyRef = doc(collection(db, pointsCollection.path)), tailRef = doc(collection(db, pointsCollection.path));
            batch.set(headRef, headData); batch.set(bodyRef, bodyData); batch.set(tailRef, tailData);
            const snakeData = { name: `Snake ${snakes.filter(s => s.name.startsWith("Snake")).length + 1}`, path: [headRef.id, bodyRef.id, tailRef.id] };
            batch.set(doc(collection(db, snakesCollection.path)), snakeData);
            await batch.commit();
        });

        async function clearCollection(collectionRef) {
             const batch = writeBatch(db); const snapshot = await getDocs(collectionRef);
             snapshot.forEach(doc => batch.delete(doc.ref)); await batch.commit();
        }

        clearBoardBtn.addEventListener('click', () => {
            showConfirmationModal('Are you sure you want to clear the entire board?', async () => {
                await Promise.all([ clearCollection(snakesCollection), clearCollection(pointsCollection), clearCollection(notesCollection), setDoc(noteBoxDocRef, { content: '' }) ]);
            }, 'Clear Board');
        });

        // --- INITIALIZATION ---
        async function initFirebase() {
            const firebaseConfig = {
              apiKey: "AIzaSyCkhSNxLzT5aphPaz5lQnXNtmEbYS7RUDU", authDomain: "storyplanner-7ee69.firebaseapp.com",
              projectId: "storyplanner-7ee69", storageBucket: "storyplanner-7ee69.appspot.com",
              messagingSenderId: "45084211794", appId: "1:45084211794:web:e9d1b8634e77a20611bd8b"
            };
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app); auth = getAuth(app); setLogLevel('error');
            snakesCollection = collection(db, `snakes`); pointsCollection = collection(db, `points`);
            notesCollection = collection(db, `notes`); noteBoxDocRef = doc(db, 'noteBox', 'mainNote');
            onAuthStateChanged(auth, user => {
                if (user) { userInfoDiv.innerHTML = `<strong>Your ID:</strong> ${user.uid}`; setupRealtimeListeners(); }
                else { userInfoDiv.textContent = 'Authenticating...'; }
            });
            try { await signInAnonymously(auth); } catch (error) { console.error("Authentication failed:", error); userInfoDiv.textContent = 'Authentication failed.'; }
        }
        
        function processAndDraw(localSnakes, localPoints, localNotes) {
            points = localPoints.map(pData => { const p = new Point(pData.x, pData.y, pData.type); p.id = pData.id; return p; });
            notes = localNotes.map(nData => { const n = new Note(nData.text, nData.attachedPointId); n.id = nData.id; n.width = nData.width; n.height = nData.height; n.offsetX = nData.offsetX; n.offsetY = nData.offsetY; return n; });
            const pointMap = new Map(points.map(p => [p.id, p]));
            snakes = localSnakes.map(sData => { const s = { ...sData }; s.path = sData.path ? sData.path.map(id => pointMap.get(id)).filter(p => p) : []; return s; });
            snakeControlsContainer.innerHTML = '';
            if (snakes.length > 0) {
                 snakeControlsContainer.classList.add('pt-2', 'border-t', 'dark:border-gray-700');
                 snakes.forEach(createSnakeDropdownMenu);
            } else { snakeControlsContainer.classList.remove('pt-2', 'border-t', 'dark:border-gray-700'); }
            
            draw();
        }

        function setupRealtimeListeners() {
            let localSnakes = [], localPoints = [], localNotes = [];
            onSnapshot(snakesCollection, (s) => { localSnakes = s.docs.map(d => ({ id: d.id, ...d.data() })); processAndDraw(localSnakes, localPoints, localNotes); }, (e) => console.error("Snakes listener error:", e));
            onSnapshot(pointsCollection, (s) => { localPoints = s.docs.map(d => ({ id: d.id, ...d.data() })); processAndDraw(localSnakes, localPoints, localNotes); }, (e) => console.error("Points listener error:", e));
            onSnapshot(notesCollection, (s) => { localNotes = s.docs.map(d => ({ id: d.id, ...d.data() })); processAndDraw(localSnakes, localPoints, localNotes); }, (e) => console.error("Notes listener error:", e));
            onSnapshot(noteBoxDocRef, (d) => { if (d.exists()) { const data = d.data(); if (noteBoxInput.value !== data.content) { noteBoxInput.value = data.content; } } }, (e) => console.error("Note box listener error:", e));
        }

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseout', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('contextmenu', handleContextMenu);
            canvas.addEventListener('dblclick', handleDoubleClick);
            window.addEventListener('keydown', handleKeyDown);
            toggleThemeBtn.addEventListener('click', toggleTheme);
            
            const saveNoteBox = debounce(() => { 
                setDoc(noteBoxDocRef, { content: noteBoxInput.value }); 
            }, 500);
            noteBoxInput.addEventListener('input', saveNoteBox);
            
            // --- Drag and Drop for new point ---
            function handleNewPointDragMove(e) {
                e.preventDefault();
                const worldCoords = screenToWorld(e.offsetX, e.offsetY);
                draggingNewPointState.x = worldCoords.x;
                draggingNewPointState.y = worldCoords.y;
                draggingNewPointState.dropTarget = findClosestLineSegment(worldCoords.x, worldCoords.y);
                if (draggingNewPointState.dropTarget) {
                    draggingNewPointState.x = draggingNewPointState.dropTarget.point.x;
                    draggingNewPointState.y = draggingNewPointState.dropTarget.point.y;
                }
                draw();
            }

            async function handleNewPointDragEnd(e) {
                window.removeEventListener('mousemove', handleNewPointDragMove);
                window.removeEventListener('mouseup', handleNewPointDragEnd);
                document.body.style.cursor = 'default';
                
                if (draggingNewPointState.dropTarget) {
                    const { snake, segmentIndex, point } = draggingNewPointState.dropTarget;
                    const newPointData = { x: point.x, y: point.y, type: 'body' };
                    try {
                        const newPointRef = await addDoc(pointsCollection, newPointData);
                        const newPathArray = snake.path.map(p => p.id);
                        newPathArray.splice(segmentIndex + 1, 0, newPointRef.id);
                        await updateDoc(doc(snakesCollection, snake.id), { path: newPathArray });
                    } catch (error) {
                        console.error("Error adding new point:", error);
                    }
                }
                draggingNewPointState.active = false;
                draw();
            }

            addPointBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                draggingNewPointState.active = true;
                const worldCoords = screenToWorld(e.clientX, e.clientY); // Initial position
                draggingNewPointState.x = worldCoords.x;
                draggingNewPointState.y = worldCoords.y;
                document.body.style.cursor = 'grabbing';
                window.addEventListener('mousemove', handleNewPointDragMove);
                window.addEventListener('mouseup', handleNewPointDragEnd);
            });


            initFirebase();
        }

        init();
    </script>
</body>
</html>
