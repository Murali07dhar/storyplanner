<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Snake Blackboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        #whiteboard {
            cursor: grab;
            touch-action: none;
        }
        #whiteboard.panning {
            cursor: grabbing;
        }
        .dropdown-content {
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
            transform-origin: top;
        }
        #note-editor {
            font-family: 'Inter', sans-serif;
            resize: none;
        }
        .modal-panel {
             transition: opacity 0.2s ease-out, transform 0.2s ease-out;
        }
    </style>
</head>
<body class="bg-gray-900 h-screen w-screen overflow-hidden flex flex-col items-center justify-center p-4">

    <div class="w-full h-full bg-black rounded-xl shadow-lg border border-gray-700 relative overflow-hidden">
        
        <div id="controls" class="absolute top-4 left-4 z-20 p-4 bg-gray-800/80 backdrop-blur-sm rounded-lg shadow border border-gray-600 flex flex-col space-y-2 max-h-[90vh] overflow-y-auto">
            <h2 class="font-bold text-gray-200 text-lg">Controls</h2>
            <div class="text-sm text-gray-300 bg-gray-700/50 p-2 rounded-md">
                <p><strong>Pan:</strong> Middle-click + Drag</p>
                <p><strong>Add Note:</strong> Right-click on point</p>
            </div>
            <div id="userInfo" class="text-xs text-gray-400 bg-gray-700 p-2 rounded-md break-all">Connecting...</div>
            <button id="createSnakeBtn" class="w-full px-4 py-2 bg-blue-500 text-white font-semibold rounded-md hover:bg-blue-600 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">Create Snake</button>
            <button id="clearBoardBtn" class="w-full px-4 py-2 bg-gray-500 text-white font-semibold rounded-md hover:bg-gray-600 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">Clear Board</button>
            
            <div id="snakeControlsContainer" class="flex flex-col space-y-2"></div>
        </div>

        <canvas id="whiteboard"></canvas>

    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, onSnapshot, addDoc, updateDoc, deleteDoc, writeBatch, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- SETUP ---
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const parentContainer = canvas.parentElement;

        // --- UI ELEMENTS ---
        const controlsPanel = document.getElementById('controls');
        const createSnakeBtn = document.getElementById('createSnakeBtn');
        const clearBoardBtn = document.getElementById('clearBoardBtn');
        const snakeControlsContainer = document.getElementById('snakeControlsContainer');
        const userInfoDiv = document.getElementById('userInfo');
        
        // --- GLOBAL & FIRESTORE STATE ---
        let db, auth;
        let snakesCollection, pointsCollection, notesCollection;
        
        // Local state, populated by Firestore
        let snakes = []; 
        let points = []; 
        let notes = [];

        // --- VIEWPORT & INTERACTION STATE ---
        const view = { x: 0, y: 0 }; // The current pan offset of the canvas
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        // Local UI state
        let draggedPoint = null;
        let isDraggingPoint = false;
        let draggedSnake = null;
        let isDraggingSnake = false;
        let resizedNote = null;
        let isResizingNote = false;
        let dragStart = { x: 0, y: 0 };
        
        // --- CONSTANTS ---
        const POINT_RADIUS = 12;
        const STRETCH_LIMIT = 300; 
        const COLORS = {
            head: '#6EE7B7', // Lighter green for head
            body: '#0EA5E9', 
            tail: '#34D399', // Changed from red to green
            line: '#E5E7EB', // Light gray for text, like chalk
            noteBg: '#FEF9C3', 
            noteBorder: '#FDE047', 
            noteText: '#1F2937', // Dark text for yellow notes
            link: '#60A5FA' // Lighter blue for links
        };
        const LABEL_FONT = 'bold 16px Inter';
        const LABEL_HEIGHT = 16;
        const NOTE_FONT = '14px Inter';
        const MIN_NOTE_WIDTH = 80;
        const MIN_NOTE_HEIGHT = 40;

        // --- UTILITY FUNCTIONS ---
        function isValidUrl(string) {
            try {
                const url = new URL(string);
                return url.protocol === "http:" || url.protocol === "https:";
            } catch (_) {
                return false;  
            }
        }
        
        // Converts screen coordinates (from mouse event) to world coordinates (on the canvas)
        function getMouseWorldPos(e) {
            return {
                x: e.offsetX - view.x,
                y: e.offsetY - view.y
            };
        }


        // --- CLASSES ---
        class Point {
            constructor(x, y, type) {
                this.id = null;
                this.x = x;
                this.y = y;
                this.type = type;
                this.originalX = 0;
                this.originalY = 0;
            }
            draw(angle = 0) {
                if (this.type === 'head') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    ctx.fillStyle = COLORS.head;
                    ctx.beginPath();
                    // Increased head size
                    ctx.ellipse(0, 0, POINT_RADIUS * 1.4, POINT_RADIUS * 1.1, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(POINT_RADIUS * 0.5, -POINT_RADIUS * 0.4, 2, 0, Math.PI * 2);
                    ctx.arc(POINT_RADIUS * 0.5, POINT_RADIUS * 0.4, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(POINT_RADIUS * 0.6, -POINT_RADIUS * 0.4, 1, 0, Math.PI * 2);
                    ctx.arc(POINT_RADIUS * 0.6, POINT_RADIUS * 0.4, 1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else if (this.type === 'tail') {
                    ctx.fillStyle = COLORS.tail;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + POINT_RADIUS);
                    ctx.lineTo(this.x - POINT_RADIUS, this.y - POINT_RADIUS / 2);
                    ctx.lineTo(this.x + POINT_RADIUS, this.y - POINT_RADIUS / 2);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, POINT_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = COLORS[this.type];
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)'; // Light border for contrast
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            isClicked(mouseX, mouseY) {
                const dist = Math.hypot(mouseX - this.x, mouseY - this.y);
                return dist < POINT_RADIUS * 1.4; // Adjust click area for larger head
            }
        }

        class Note {
            constructor(text, attachedPointId) {
                this.id = null;
                this.text = text;
                this.attachedPointId = attachedPointId;
                this.width = 160;
                this.height = 100;
                this.originalWidth = 0;
                this.originalHeight = 0;
                this.offsetX = 40;
                this.offsetY = -50;
            }

            wrapText(context, text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = '';
                context.font = NOTE_FONT;
                context.textAlign = 'left';
                context.textBaseline = 'top';
                for(let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = context.measureText(testLine);
                    if (metrics.width > maxWidth && n > 0) {
                        context.fillText(line, x, y);
                        line = words[n] + ' ';
                        y += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                context.fillText(line, x, y);
            }
            
            draw(parentPoint) {
                const noteX = parentPoint.x + this.offsetX;
                const noteY = parentPoint.y + this.offsetY;
                ctx.beginPath();
                ctx.moveTo(parentPoint.x, parentPoint.y);
                ctx.lineTo(noteX, noteY + this.height / 2);
                ctx.strokeStyle = '#9CA3AF';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = COLORS.noteBg;
                ctx.strokeStyle = COLORS.noteBorder;
                ctx.lineWidth = 1.5;
                ctx.fillRect(noteX, noteY, this.width, this.height);
                ctx.strokeRect(noteX, noteY, this.width, this.height);
                const isLink = isValidUrl(this.text);
                ctx.fillStyle = isLink ? COLORS.link : COLORS.noteText;
                this.wrapText(ctx, this.text, noteX + 8, noteY + 8, this.width - 24, 18);
                const deleteIconX = noteX + this.width - 10;
                const deleteIconY = noteY + 10;
                const iconSize = 6;
                ctx.beginPath();
                ctx.moveTo(deleteIconX - iconSize, deleteIconY - iconSize);
                ctx.lineTo(deleteIconX + iconSize, deleteIconY + iconSize);
                ctx.moveTo(deleteIconX + iconSize, deleteIconY - iconSize);
                ctx.lineTo(deleteIconX - iconSize, deleteIconY + iconSize);
                ctx.strokeStyle = '#6B7280';
                ctx.lineWidth = 2;
                ctx.stroke();
                if (isLink) {
                    const linkIconX = noteX + this.width - 12;
                    const linkIconY = noteY + this.height - 12;
                    ctx.strokeStyle = COLORS.link;
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(linkIconX, linkIconY, 6, 6);
                    ctx.beginPath();
                    ctx.moveTo(linkIconX + 3, linkIconY);
                    ctx.lineTo(linkIconX + 9, linkIconY - 6);
                    ctx.moveTo(linkIconX + 4, linkIconY - 6);
                    ctx.lineTo(linkIconX + 9, linkIconY - 6);
                    ctx.lineTo(linkIconX + 9, linkIconY - 1);
                    ctx.stroke();
                }
                
                const resizeHandleX = noteX + this.width;
                const resizeHandleY = noteY + this.height;
                ctx.fillStyle = '#9CA3AF';
                ctx.beginPath();
                ctx.moveTo(resizeHandleX, resizeHandleY - 10);
                ctx.lineTo(resizeHandleX - 10, resizeHandleY);
                ctx.lineTo(resizeHandleX, resizeHandleY);
                ctx.closePath();
                ctx.fill();
            }
            
            isBodyClicked(mouseX, mouseY, parentPoint) {
                const noteX = parentPoint.x + this.offsetX;
                const noteY = parentPoint.y + this.offsetY;
                return mouseX > noteX && mouseX < noteX + this.width &&
                       mouseY > noteY && mouseY < noteY + this.height;
            }

            isDeleteClicked(mouseX, mouseY, parentPoint) {
                const noteX = parentPoint.x + this.offsetX;
                const noteY = parentPoint.y + this.offsetY;
                const deleteIconX = noteX + this.width - 10;
                const deleteIconY = noteY + 10;
                const hitArea = 10;
                return mouseX > deleteIconX - hitArea && mouseX < deleteIconX + hitArea &&
                       mouseY > deleteIconY - hitArea && mouseY < deleteIconY + hitArea;
            }
            
            isLinkIconClicked(mouseX, mouseY, parentPoint) {
                const noteX = parentPoint.x + this.offsetX;
                const noteY = parentPoint.y + this.offsetY;
                const linkIconX = noteX + this.width - 12;
                const linkIconY = noteY + this.height - 12;
                const hitArea = 12;
                return mouseX > linkIconX - hitArea && mouseX < linkIconX + hitArea &&
                       mouseY > linkIconY - hitArea && mouseY < linkIconY + hitArea;
            }

            isResizeClicked(mouseX, mouseY, parentPoint) {
                const noteX = parentPoint.x + this.offsetX;
                const noteY = parentPoint.y + this.offsetY;
                const resizeHandleX = noteX + this.width;
                const resizeHandleY = noteY + this.height;
                const hitArea = 15;
                return mouseX > resizeHandleX - hitArea && mouseX < resizeHandleX + hitArea &&
                       mouseY > resizeHandleY - hitArea && mouseY < resizeHandleY + hitArea;
            }
        }
        
        // --- CORE DRAWING FUNCTIONS ---
        function resizeCanvas() {
            canvas.width = parentContainer.clientWidth;
            canvas.height = parentContainer.clientHeight;
            draw();
        }

        function draw() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(view.x, view.y); // Apply the pan offset

            // Draw snake bodies
            snakes.forEach(snakeObj => {
                if (snakeObj.path && snakeObj.path.length > 1) {
                    // Draw the main yellow body
                    ctx.beginPath();
                    ctx.moveTo(snakeObj.path[0].x, snakeObj.path[0].y);
                    for (let i = 1; i < snakeObj.path.length; i++) {
                        ctx.lineTo(snakeObj.path[i].x, snakeObj.path[i].y);
                    }
                    ctx.strokeStyle = '#FBBF24'; // A nice yellow color
                    ctx.lineWidth = POINT_RADIUS * 1.4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();

                    // Draw randomized green spots on top
                    ctx.fillStyle = '#16A34A'; // A solid green color
                    for (let i = 0; i < snakeObj.path.length - 1; i++) {
                        const p1 = snakeObj.path[i];
                        const p2 = snakeObj.path[i+1];
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const dist = Math.hypot(dx, dy);
                        const angle = Math.atan2(dy, dx);
                        
                        // Determine the number of spots based on the length of the segment
                        const numSpots = Math.ceil(dist / 20); 

                        for (let j = 0; j < numSpots; j++) {
                            // Get a random point along the line segment
                            const t = Math.random();
                            const x = p1.x + dx * t;
                            const y = p1.y + dy * t;

                            // Add a random perpendicular offset to the spot's position
                            const offsetAngle = angle + Math.PI / 2;
                            const offsetDist = (Math.random() - 0.5) * POINT_RADIUS * 1.2;
                            const spotX = x + Math.cos(offsetAngle) * offsetDist;
                            const spotY = y + Math.sin(offsetAngle) * offsetDist;

                            // Randomize the size of the spot
                            const spotRadius = 2 + Math.random() * 3;

                            ctx.beginPath();
                            ctx.arc(spotX, spotY, spotRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            });
            
            // Draw notes
            notes.forEach(note => {
                const parentPoint = points.find(p => p.id === note.attachedPointId);
                if (parentPoint) note.draw(parentPoint);
            });
            
            // Draw points on top of lines
            points.forEach(p => {
                let angle = 0;
                const ownerSnake = snakes.find(s => s.path && s.path.some(sp => sp.id === p.id));
                if (p.type === 'head' && ownerSnake && ownerSnake.path.length > 1) {
                    const nextPoint = ownerSnake.path[1];
                    angle = Math.atan2(nextPoint.y - p.y, nextPoint.x - p.x);
                }
                p.draw(angle);
            });
            
            // Draw labels last
            snakes.forEach(snakeObj => {
                if (snakeObj.path && snakeObj.path.length > 0) {
                    const head = snakeObj.path[0];
                    ctx.fillStyle = COLORS.line;
                    ctx.font = LABEL_FONT;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(snakeObj.name, head.x, head.y - POINT_RADIUS - 5);
                }
            });

            ctx.restore(); // Restore context to pre-pan state
        }

        function getPointAt(mouseX, mouseY) {
            for (let i = points.length - 1; i >= 0; i--) {
                if (points[i].isClicked(mouseX, mouseY)) return points[i];
            }
            return null;
        }

        // --- EVENT HANDLERS ---
        function handleMouseDown(e) {
            e.preventDefault();
            const worldPos = getMouseWorldPos(e);

            // Middle mouse button for panning
            if (e.button === 1) {
                isPanning = true;
                panStart.x = e.offsetX;
                panStart.y = e.offsetY;
                canvas.classList.add('panning');
                return;
            }

            if (e.button !== 0) return;

            const clickedPoint = getPointAt(worldPos.x, worldPos.y);
            if (clickedPoint) {
                draggedPoint = clickedPoint;
                isDraggingPoint = true;
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            for (let i = notes.length - 1; i >= 0; i--) {
                const note = notes[i];
                const parentPoint = points.find(p => p.id === note.attachedPointId);
                if (parentPoint) {
                    if (note.isDeleteClicked(worldPos.x, worldPos.y, parentPoint)) {
                        deleteDoc(doc(notesCollection, note.id));
                        return;
                    }

                    if (note.isResizeClicked(worldPos.x, worldPos.y, parentPoint)) {
                        isResizingNote = true;
                        resizedNote = note;
                        resizedNote.originalWidth = note.width;
                        resizedNote.originalHeight = note.height;
                        dragStart = { x: worldPos.x, y: worldPos.y };
                        canvas.style.cursor = 'nwse-resize';
                        return;
                    }
                    
                    if (isValidUrl(note.text) && note.isLinkIconClicked(worldPos.x, worldPos.y, parentPoint)) {
                        window.open(note.text, '_blank');
                        return;
                    }

                    if (note.isBodyClicked(worldPos.x, worldPos.y, parentPoint)) {
                        createNoteInput(note);
                        return;
                    }
                }
            }

            for (let i = snakes.length - 1; i >= 0; i--) {
                const snake = snakes[i];
                if (!snake.path || snake.path.length === 0) continue;
                const head = snake.path[0];
                ctx.font = LABEL_FONT;
                const metrics = ctx.measureText(snake.name);
                const labelX = head.x - metrics.width / 2;
                const labelY = head.y - POINT_RADIUS - 5 - LABEL_HEIGHT;
                if (worldPos.x > labelX && worldPos.x < labelX + metrics.width && worldPos.y > labelY && worldPos.y < labelY + LABEL_HEIGHT) {
                    draggedSnake = snake;
                    isDraggingSnake = true;
                    dragStart = { x: worldPos.x, y: worldPos.y };
                    draggedSnake.path.forEach(p => { p.originalX = p.x; p.originalY = p.y; });
                    canvas.style.cursor = 'move';
                    return;
                }
            }
        }
        
        async function handleContextMenu(e) {
            e.preventDefault();
            const worldPos = getMouseWorldPos(e);
            const clickedPoint = getPointAt(worldPos.x, worldPos.y);
            if(clickedPoint) {
                const existingNote = notes.find(n => n.attachedPointId === clickedPoint.id);
                if(existingNote){
                    createNoteInput(existingNote);
                } else {
                    const newNoteData = {
                        text: "Type something...", attachedPointId: clickedPoint.id,
                        width: 160, height: 100, offsetX: 40, offsetY: -50,
                    };
                    try {
                        const docRef = await addDoc(notesCollection, newNoteData);
                        const tempNote = new Note(newNoteData.text, newNoteData.attachedPointId);
                        tempNote.id = docRef.id;
                        createNoteInput(tempNote);
                    } catch (error) {
                        console.error("Error creating note:", error);
                    }
                }
            }
        }

        function handleMouseMove(e) {
            e.preventDefault();
            
            if (isPanning) {
                const dx = e.offsetX - panStart.x;
                const dy = e.offsetY - panStart.y;
                view.x += dx;
                view.y += dy;
                panStart.x = e.offsetX;
                panStart.y = e.offsetY;
                draw();
                return;
            }

            const worldPos = getMouseWorldPos(e);

            if (isResizingNote && resizedNote) {
                const deltaX = worldPos.x - dragStart.x;
                const deltaY = worldPos.y - dragStart.y;
                resizedNote.width = Math.max(MIN_NOTE_WIDTH, resizedNote.originalWidth + deltaX);
                resizedNote.height = Math.max(MIN_NOTE_HEIGHT, resizedNote.originalHeight + deltaY);
                draw();
            } else if (isDraggingPoint && draggedPoint) {
                let currentX = worldPos.x, currentY = worldPos.y;
                let ownerSnake = null, pointIndexInSnake = -1;
                for (const snake of snakes) {
                    if(!snake.path) continue;
                    const index = snake.path.findIndex(p => p.id === draggedPoint.id);
                    if (index > -1) {
                        ownerSnake = snake; pointIndexInSnake = index; break;
                    }
                }
                
                if (ownerSnake) {
                     const ownerSnakePath = ownerSnake.path;
                     const prev = ownerSnakePath[pointIndexInSnake - 1], next = ownerSnakePath[pointIndexInSnake + 1];
                     if (prev) {
                         const dist = Math.hypot(currentX - prev.x, currentY - prev.y);
                         if (dist > STRETCH_LIMIT) {
                             const angle = Math.atan2(currentY - prev.y, currentX - prev.x);
                             currentX = prev.x + STRETCH_LIMIT * Math.cos(angle);
                             currentY = prev.y + STRETCH_LIMIT * Math.sin(angle);
                         }
                     }
                     if (next) {
                         const dist = Math.hypot(currentX - next.x, currentY - next.y);
                         if (dist > STRETCH_LIMIT) {
                             const angle = Math.atan2(currentY - next.y, currentX - next.x);
                             currentX = next.x + STRETCH_LIMIT * Math.cos(angle);
                             currentY = next.y + STRETCH_LIMIT * Math.sin(angle);
                         }
                     }
                }
                draggedPoint.x = currentX;
                draggedPoint.y = currentY;
                draw();
            } else if (isDraggingSnake && draggedSnake) {
                const deltaX = worldPos.x - dragStart.x, deltaY = worldPos.y - dragStart.y;
                draggedSnake.path.forEach(p => { p.x = p.originalX + deltaX; p.y = p.originalY + deltaY; });
                draw();
            }
        }

        function handleMouseUp(e) {
            e.preventDefault();

            if (e.button === 1) {
                isPanning = false;
                canvas.classList.remove('panning');
            }

            if (isDraggingPoint && draggedPoint) {
                updateDoc(doc(pointsCollection, draggedPoint.id), { x: draggedPoint.x, y: draggedPoint.y });
            }
            if (isDraggingSnake && draggedSnake) {
                const batch = writeBatch(db);
                draggedSnake.path.forEach(p => {
                    const pointRef = doc(pointsCollection, p.id);
                    batch.update(pointRef, { x: p.x, y: p.y });
                });
                batch.commit();
            }
            if (isResizingNote && resizedNote) {
                updateDoc(doc(notesCollection, resizedNote.id), { width: resizedNote.width, height: resizedNote.height });
            }

            isDraggingPoint = isDraggingSnake = isResizingNote = false;
            draggedPoint = draggedSnake = resizedNote = null;
            canvas.style.cursor = 'grab';
        }
        
        // --- UI/CONTROL LOGIC ---
        function showConfirmationModal(message, onConfirm) {
            document.getElementById('confirmation-modal-overlay')?.remove();
            const overlay = document.createElement('div');
            overlay.id = 'confirmation-modal-overlay';
            overlay.className = 'fixed inset-0 bg-black/60 z-40 flex items-center justify-center p-4';
            const panel = document.createElement('div');
            panel.className = 'modal-panel bg-white rounded-lg shadow-xl p-6 w-full max-w-sm transform opacity-0 translate-y-4';
            const text = document.createElement('p');
            text.className = 'text-gray-800 mb-6 text-lg';
            text.textContent = message;
            const btnContainer = document.createElement('div');
            btnContainer.className = 'flex justify-end space-x-3';
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'px-5 py-2 bg-gray-200 text-gray-800 font-semibold rounded-md hover:bg-gray-300 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400';
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'Clear Board';
            confirmBtn.className = 'px-5 py-2 bg-red-500 text-white font-semibold rounded-md hover:bg-red-600 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400';
            btnContainer.append(cancelBtn, confirmBtn);
            panel.append(text, btnContainer);
            overlay.appendChild(panel);
            setTimeout(() => {
                panel.classList.remove('opacity-0', 'translate-y-4');
                panel.classList.add('opacity-100', 'translate-y-0');
            }, 10);
            const closeModal = () => {
                panel.classList.add('opacity-0');
                setTimeout(() => overlay.remove(), 200);
            };
            cancelBtn.addEventListener('click', closeModal);
            confirmBtn.addEventListener('click', () => {
                onConfirm();
                closeModal();
            });
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closeModal();
            });
        }

        function createNoteInput(note) {
            document.getElementById('note-editor')?.remove();
            const parentPoint = points.find(p => p.id === note.attachedPointId);
            if (!parentPoint) return;
            const textarea = document.createElement('textarea');
            textarea.id = 'note-editor';
            textarea.value = note.text === "Type something..." ? "" : note.text;
            textarea.style.position = 'absolute';
            // Position the textarea relative to the panned view
            textarea.style.left = `${canvas.offsetLeft + parentPoint.x + note.offsetX + view.x}px`;
            textarea.style.top = `${canvas.offsetTop + parentPoint.y + note.offsetY + view.y}px`;
            textarea.style.width = `${note.width}px`;
            textarea.style.height = `${note.height}px`;
            textarea.style.zIndex = '30';
            textarea.className = 'p-2 border-2 border-blue-500 rounded-md shadow-lg focus:outline-none bg-yellow-50 text-gray-900';
            parentContainer.appendChild(textarea);
            textarea.focus();
            textarea.select();
            const finishEditing = () => {
                if(document.body.contains(textarea)) {
                    const newText = textarea.value.trim() === '' ? 'Type something...' : textarea.value;
                    if (note.text !== newText) {
                         updateDoc(doc(notesCollection, note.id), { text: newText });
                    }
                    parentContainer.removeChild(textarea);
                }
            };
            textarea.addEventListener('blur', finishEditing);
            textarea.addEventListener('keydown', e => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); finishEditing(); } 
                else if (e.key === 'Escape') { finishEditing(); }
            });
        }

        async function removeSnake(snakeId) {
            const snakeToRemove = snakes.find(s => s.id === snakeId);
            if (!snakeToRemove || !snakeToRemove.path) return;
            const batch = writeBatch(db);
            batch.delete(doc(snakesCollection, snakeId));
            const pointIdsToRemove = new Set(snakeToRemove.path.map(p => p.id));
            pointIdsToRemove.forEach(pointId => {
                batch.delete(doc(pointsCollection, pointId));
            });
            const notesSnapshot = await getDocs(notesCollection);
            notesSnapshot.forEach(noteDoc => {
                if (pointIdsToRemove.has(noteDoc.data().attachedPointId)) {
                    batch.delete(noteDoc.ref);
                }
            });
            await batch.commit();
        }
        
        async function addBodyPointToSnake(snakeId) {
            const snake = snakes.find(s => s.id === snakeId);
            if (!snake || !snake.path || snake.path.length < 2) return;
            const beforeTail = snake.path[snake.path.length - 2];
            const tail = snake.path[snake.path.length - 1];
            const newPointData = {
                x: (beforeTail.x + tail.x) / 2,
                y: (beforeTail.y + tail.y) / 2,
                type: 'body'
            };
            const newPointRef = await addDoc(pointsCollection, newPointData);
            const newPathArray = snake.path.map(p => p.id);
            newPathArray.splice(newPathArray.length - 1, 0, newPointRef.id);
            await updateDoc(doc(snakesCollection, snakeId), { path: newPathArray });
        }

        function showRenameInput(menuContainer) {
            const snakeId = menuContainer.dataset.id;
            const snake = snakes.find(s => s.id === snakeId);
            const toggleButton = menuContainer.querySelector('button');
            const dropdownContent = menuContainer.querySelector('.dropdown-content');
            dropdownContent.classList.add('hidden');
            toggleButton.style.display = 'none';
            const input = document.createElement('input');
            input.type = 'text';
            input.value = snake.name;
            input.className = 'w-full px-3 py-2 bg-gray-600 border border-blue-400 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400 text-white';
            menuContainer.insertBefore(input, toggleButton);
            input.focus();
            input.select();
            const finishRename = () => {
                const newName = input.value.trim();
                if (newName && newName !== snake.name) {
                    updateDoc(doc(snakesCollection, snakeId), { name: newName });
                }
                menuContainer.removeChild(input);
                toggleButton.style.display = 'block';
            };
            input.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === 'Escape') finishRename(); });
            input.addEventListener('blur', finishRename);
        }

        function createSnakeDropdownMenu(snake) {
            const menuContainer = document.createElement('div');
            menuContainer.className = 'relative snake-menu';
            menuContainer.dataset.id = snake.id;
            const toggleButton = document.createElement('button');
            toggleButton.innerHTML = `${snake.name} Actions <span class="text-xs">â–¼</span>`;
            toggleButton.className = 'w-full text-left px-3 py-2 bg-gray-700 text-gray-200 font-semibold rounded-md hover:bg-gray-600 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-gray-500';
            const dropdownContent = document.createElement('div');
            dropdownContent.className = 'dropdown-content absolute left-0 right-0 mt-1 bg-gray-700 border border-gray-600 rounded-md shadow-lg p-2 space-y-1 hidden z-10';
            dropdownContent.innerHTML = `<button data-action="rename" class="w-full text-left px-3 py-1.5 text-sm text-gray-200 hover:bg-gray-600 rounded-md">Rename</button><button data-action="add-body" class="w-full text-left px-3 py-1.5 text-sm text-sky-400 hover:bg-gray-600 rounded-md">Add Body Point</button><div class="border-t border-gray-600 my-1"></div><button data-action="remove" class="w-full text-left px-3 py-1.5 text-sm text-red-400 hover:bg-gray-600 rounded-md">Remove Snake</button>`;
            menuContainer.append(toggleButton, dropdownContent);
            snakeControlsContainer.appendChild(menuContainer);
        }

        snakeControlsContainer.addEventListener('click', e => {
            const button = e.target.closest('button');
            if (!button) return;
            const menuContainer = e.target.closest('.snake-menu');
            if (!menuContainer) return;
            if (button === menuContainer.querySelector('button')) {
                menuContainer.querySelector('.dropdown-content').classList.toggle('hidden');
                return;
            }
            const action = button.dataset.action;
            if (action) {
                const snakeId = menuContainer.dataset.id;
                if (action === 'rename') showRenameInput(menuContainer);
                else if (action === 'add-body') addBodyPointToSnake(snakeId);
                else if (action === 'remove') removeSnake(snakeId);
            }
        });

        createSnakeBtn.addEventListener('click', async () => {
            const batch = writeBatch(db);
            const snakesPerRow = 8;
            const horizontalSpacing = 150;
            const verticalSpacing = 350;
            // Place new snakes relative to the current view, not absolute 0,0
            const initialXOffset = -view.x + controlsPanel.offsetWidth + 80;
            const initialYOffset = -view.y + 100;

            const snakeIndex = snakes.length;
            const rowIndex = Math.floor(snakeIndex / snakesPerRow);
            const colIndex = snakeIndex % snakesPerRow;

            const startX = initialXOffset + (colIndex * horizontalSpacing);
            const startY = initialYOffset + (rowIndex * verticalSpacing);
            
            const headData = { x: startX, y: startY, type: 'head' };
            const bodyData = { x: startX, y: startY + 100, type: 'body' };
            const tailData = { x: startX, y: startY + 200, type: 'tail' };
            
            const headRef = doc(collection(db, pointsCollection.path));
            const bodyRef = doc(collection(db, pointsCollection.path));
            const tailRef = doc(collection(db, pointsCollection.path));

            batch.set(headRef, headData);
            batch.set(bodyRef, bodyData);
            batch.set(tailRef, tailData);
            
            const snakeData = {
                name: `Snake ${snakes.length + 1}`,
                path: [headRef.id, bodyRef.id, tailRef.id]
            };
            const snakeRef = doc(collection(db, snakesCollection.path));
            batch.set(snakeRef, snakeData);
            await batch.commit();
        });

        async function clearCollection(collectionRef) {
             const batch = writeBatch(db);
             const snapshot = await getDocs(collectionRef);
             snapshot.forEach(doc => batch.delete(doc.ref));
             await batch.commit();
        }

        clearBoardBtn.addEventListener('click', () => {
            if (document.getElementById('note-editor') || document.getElementById('confirmation-modal-overlay')) return;
            showConfirmationModal('Are you sure you want to clear the entire board?', async () => {
                await Promise.all([
                    clearCollection(snakesCollection),
                    clearCollection(pointsCollection),
                    clearCollection(notesCollection)
                ]);
                // Reset the view after clearing
                view.x = 0;
                view.y = 0;
                draw();
            });
        });

        // --- INITIALIZATION ---
        async function initFirebase() {
            const firebaseConfig = {
             apiKey: "AIzaSyCkhSNxLzT5aphPaz5lQnXNtmEbYS7RUDU",
             authDomain: "storyplanner-7ee69.firebaseapp.com",
             projectId: "storyplanner-7ee69",
             storageBucket: "storyplanner-7ee69.appspot.com",
             messagingSenderId: "45084211794",
             appId: "1:45084211794:web:e9d1b8634e77a20611bd8b"
            };

            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            setLogLevel('error');

            snakesCollection = collection(db, `snakes`);
            pointsCollection = collection(db, `points`);
            notesCollection = collection(db, `notes`);

            onAuthStateChanged(auth, user => {
                if (user) {
                    userInfoDiv.innerHTML = `<strong>Your ID:</strong> ${user.uid}`;
                    setupRealtimeListeners();
                } else {
                     userInfoDiv.textContent = 'Authenticating...';
                }
            });

            try {
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Authentication failed:", error);
                userInfoDiv.textContent = 'Authentication failed.';
            }
        }
        
        function processAndDraw(localSnakes, localPoints, localNotes) {
            points = localPoints.map(pData => {
                const point = new Point(pData.x, pData.y, pData.type);
                point.id = pData.id;
                return point;
            });

            notes = localNotes.map(nData => {
                 const note = new Note(nData.text, nData.attachedPointId);
                 note.id = nData.id;
                 note.width = nData.width;
                 note.height = nData.height;
                 note.offsetX = nData.offsetX;
                 note.offsetY = nData.offsetY;
                 return note;
            });

            const pointMap = new Map(points.map(p => [p.id, p]));
            
            snakes = localSnakes.map(sData => {
                const snake = { ...sData };
                snake.path = sData.path ? sData.path.map(pointId => pointMap.get(pointId)).filter(p => p) : [];
                return snake;
            });
            
            snakeControlsContainer.innerHTML = '';
            if (snakes.length > 0) {
                 snakeControlsContainer.classList.add('pt-2', 'border-t', 'border-gray-600');
                 snakes.forEach(createSnakeDropdownMenu);
            } else {
                 snakeControlsContainer.classList.remove('pt-2', 'border-t', 'border-gray-600');
            }

            draw();
        }

        function setupRealtimeListeners() {
            let localSnakes = [];
            let localPoints = [];
            let localNotes = [];
            
            onSnapshot(snakesCollection, (snapshot) => {
                localSnakes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                processAndDraw(localSnakes, localPoints, localNotes);
            }, (error) => console.error("Error listening to snakes:", error));

            onSnapshot(pointsCollection, (snapshot) => {
                localPoints = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                processAndDraw(localSnakes, localPoints, localNotes);
            }, (error) => console.error("Error listening to points:", error));
            
            onSnapshot(notesCollection, (snapshot) => {
                localNotes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                processAndDraw(localSnakes, localPoints, localNotes);
            }, (error) => console.error("Error listening to notes:", error));
        }

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseout', handleMouseUp);
            canvas.addEventListener('contextmenu', handleContextMenu);
            
            initFirebase();
            draw();
        }

        init();
    </script>
</body>
</html>
