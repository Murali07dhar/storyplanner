<!DOCTYPE html>
<html lang="en" class=""> <!-- Add/remove 'dark' class here to toggle theme -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Snake Whiteboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        #whiteboard {
            cursor: grab;
            touch-action: none;
        }
        .dropdown-content {
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
            transform-origin: top;
        }
        #note-editor, #noteBoxInput {
            font-family: 'Inter', sans-serif;
            resize: none;
        }
        .modal-panel {
             transition: opacity 0.2s ease-out, transform 0.2s ease-out;
        }
        /* Style for dark mode */
        .dark body {
            background-color: #111827; /* gray-900 */
        }
        .dark #controls, .dark #noteBox {
            background-color: rgba(31, 41, 55, 0.8); /* bg-gray-800/80 */
            border-color: #374151; /* border-gray-700 */
        }
        .dark h2, .dark h3, .dark button, .dark .text-gray-700 {
            color: #D1D5DB; /* gray-300 */
        }
        .dark #userInfo {
            background-color: #374151; /* gray-700 */
            color: #9CA3AF; /* gray-400 */
        }
        .dark .snake-menu button {
            background-color: #374151; /* gray-700 */
            color: #E5E7EB; /* gray-200 */
        }
         .dark .snake-menu button:hover {
            background-color: #4B5563; /* gray-600 */
         }
        .dark .dropdown-content {
            background-color: #1F2937; /* gray-800 */
            border-color: #374151; /* gray-700 */
        }
        .dark .dropdown-content button:hover {
            background-color: #374151; /* gray-700 */
        }
         .dark .text-sky-700 { color: #7DD3FC; /* sky-300 */ }
         .dark .hover\:bg-sky-50:hover { background-color: rgba(56, 189, 248, 0.1); }
         .dark .text-red-700 { color: #FCA5A5; /* red-300 */ }
         .dark .hover\:bg-red-50:hover { background-color: rgba(239, 68, 68, 0.1); }
         .dark #noteBoxInput {
            background-color: #374151; /* gray-700 */
            color: #E5E7EB; /* gray-200 */
            border-color: #4B5563; /* gray-600 */
         }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col items-center justify-center p-4 bg-gray-100 dark:bg-gray-900">

    <div class="w-full h-full bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 relative overflow-hidden">
        
        <div class="absolute top-4 left-4 z-20 flex flex-col space-y-2 max-h-[90vh]">
            <div id="controls" class="p-4 bg-white/80 backdrop-blur-sm rounded-lg shadow border border-gray-200 flex flex-col space-y-2 overflow-y-auto">
                <h2 class="font-bold text-gray-700 text-lg">Controls</h2>
                <div id="userInfo" class="text-xs text-gray-500 bg-gray-100 p-2 rounded-md break-all">Connecting...</div>
                <button id="createSnakeBtn" class="w-full px-4 py-2 bg-blue-500 text-white font-semibold rounded-md hover:bg-blue-600 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">Create Snake</button>
                <button id="toggleThemeBtn" class="w-full px-4 py-2 bg-indigo-500 text-white font-semibold rounded-md hover:bg-indigo-600 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75">Toggle Theme</button>
                <button id="clearBoardBtn" class="w-full px-4 py-2 bg-gray-500 text-white font-semibold rounded-md hover:bg-gray-600 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">Clear Board</button>
                
                <div id="snakeControlsContainer" class="flex flex-col space-y-2"></div>
            </div>
            <div id="noteBox" class="p-4 bg-white/80 backdrop-blur-sm rounded-lg shadow border border-gray-200 flex flex-col space-y-2">
                <h3 class="font-bold text-gray-700 text-lg">Note Box</h3>
                <textarea id="noteBoxInput" class="w-full h-24 p-2 border rounded-md bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="Type shared notes here..."></textarea>
            </div>
        </div>

        <canvas id="whiteboard"></canvas>

    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, onSnapshot, addDoc, updateDoc, deleteDoc, writeBatch, getDocs, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- SETUP ---
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const parentContainer = canvas.parentElement;

        // --- UI ELEMENTS ---
        const controlsPanel = document.getElementById('controls');
        const createSnakeBtn = document.getElementById('createSnakeBtn');
        const clearBoardBtn = document.getElementById('clearBoardBtn');
        const toggleThemeBtn = document.getElementById('toggleThemeBtn');
        const snakeControlsContainer = document.getElementById('snakeControlsContainer');
        const userInfoDiv = document.getElementById('userInfo');
        const noteBoxInput = document.getElementById('noteBoxInput');
        
        // --- GLOBAL & FIRESTORE STATE ---
        let db, auth;
        let snakesCollection, pointsCollection, notesCollection, noteBoxDocRef;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        // Local state, populated by Firestore
        let snakes = []; 
        let points = []; 
        let notes = [];

        // --- INTERACTION STATE ---
        // Flags for active drags
        let isDraggingPoint = false;
        let isDraggingSnake = false;
        let isResizingNote = false;
        let isDraggingNote = false;
        let isPanning = false;
        
        // Objects being interacted with
        let draggedPoint = null;
        let draggedSnake = null;
        let resizedNote = null;
        let draggedNote = null;
        
        // State for initiating drags
        let potentialDrag = null; // Stores info about what *could* be dragged
        let mouseDownCoords = null; // Stores world coordinates of the last mousedown
        let panStart = { x: 0, y: 0 }; // Screen coordinates for panning

        // Viewport state for panning and zooming
        let view = { x: 0, y: 0, zoom: 1 };
        
        // --- THEME & COLORS ---
        const LIGHT_THEME = {
            background: '#FFFFFF',
            head: '#10B981', body: '#FFFFFF', tail: '#EF4444',
            line: '#374151', noteBg: '#FEF9C3', noteBorder: '#FDE047', link: '#0000EE',
            text: '#1F2937'
        };
        const DARK_THEME = {
            background: '#1F2937',
            head: '#34D399', body: '#FFFFFF', tail: '#F87171',
            line: '#9CA3AF', noteBg: '#4B5563', noteBorder: '#6B7280', link: '#60A5FA',
            text: '#F3F4F6'
        };
        let COLORS = LIGHT_THEME;
        let currentTheme = 'light';

        // --- CONSTANTS ---
        const POINT_RADIUS = 12;
        const STRETCH_LIMIT = 300; 
        const LABEL_FONT = 'bold 16px Inter';
        const LABEL_HEIGHT = 16;
        const NOTE_FONT = '14px Inter';
        const MIN_NOTE_WIDTH = 80;
        const MIN_NOTE_HEIGHT = 40;
        const MIN_ZOOM = 0.2;
        const MAX_ZOOM = 5;
        const DRAG_THRESHOLD = 4; // Pixels mouse must move to initiate a drag

        // --- UTILITY & COORDINATE FUNCTIONS ---
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        function isValidUrl(string) {
            try {
                const url = new URL(string);
                return url.protocol === "http:" || url.protocol === "https:";
            } catch (_) {
                return false;  
            }
        }

        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX / view.zoom) + view.x,
                y: (screenY / view.zoom) + view.y
            };
        }

        function worldToScreen(worldX, worldY) {
            return {
                x: (worldX - view.x) * view.zoom,
                y: (worldY - view.y) * view.zoom
            };
        }

        // --- CLASSES ---
        class Point {
            constructor(x, y, type) {
                this.id = null;
                this.x = x;
                this.y = y;
                this.type = type;
                this.originalX = 0;
                this.originalY = 0;
            }
            draw(angle = 0) {
                if (this.type === 'head') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    ctx.fillStyle = COLORS.head;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, POINT_RADIUS * 1.2, POINT_RADIUS * 0.9, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(POINT_RADIUS * 0.5, -POINT_RADIUS * 0.4, 2, 0, Math.PI * 2);
                    ctx.arc(POINT_RADIUS * 0.5, POINT_RADIUS * 0.4, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(POINT_RADIUS * 0.6, -POINT_RADIUS * 0.4, 1, 0, Math.PI * 2);
                    ctx.arc(POINT_RADIUS * 0.6, POINT_RADIUS * 0.4, 1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else if (this.type === 'tail') {
                    ctx.fillStyle = COLORS.tail;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + POINT_RADIUS);
                    ctx.lineTo(this.x - POINT_RADIUS, this.y - POINT_RADIUS / 2);
                    ctx.lineTo(this.x + POINT_RADIUS, this.y - POINT_RADIUS / 2);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, POINT_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = this.type === 'body' ? COLORS.body : COLORS[this.type];
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            isClicked(mouseX, mouseY) {
                const dist = Math.hypot(mouseX - this.x, mouseY - this.y);
                return dist < POINT_RADIUS * 1.2;
            }
        }

        class Note {
            constructor(text, attachedPointId) {
                this.id = null;
                this.text = text;
                this.attachedPointId = attachedPointId;
                this.width = 160;
                this.height = 100;
                this.originalWidth = 0;
                this.originalHeight = 0;
                this.offsetX = 40;
                this.offsetY = -50;
                this.originalOffsetX = 0;
                this.originalOffsetY = 0;
            }
            wrapText(context, text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = '';
                context.font = NOTE_FONT;
                context.textAlign = 'left';
                context.textBaseline = 'top';
                for(let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = context.measureText(testLine);
                    if (metrics.width > maxWidth && n > 0) {
                        context.fillText(line, x, y);
                        line = words[n] + ' ';
                        y += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                context.fillText(line, x, y);
            }
            
            draw(parentPoint) {
                const noteX = parentPoint.x + this.offsetX;
                const noteY = parentPoint.y + this.offsetY;
                ctx.beginPath();
                ctx.moveTo(parentPoint.x, parentPoint.y);
                ctx.lineTo(noteX, noteY + this.height / 2);
                ctx.strokeStyle = '#9CA3AF';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = COLORS.noteBg;
                ctx.strokeStyle = COLORS.noteBorder;
                ctx.lineWidth = 1.5;
                ctx.fillRect(noteX, noteY, this.width, this.height);
                ctx.strokeRect(noteX, noteY, this.width, this.height);
                const isLink = isValidUrl(this.text);
                ctx.fillStyle = isLink ? COLORS.link : COLORS.text;
                this.wrapText(ctx, this.text, noteX + 8, noteY + 8, this.width - 24, 18);
                const deleteIconX = noteX + this.width - 10;
                const deleteIconY = noteY + 10;
                const iconSize = 6;
                ctx.beginPath();
                ctx.moveTo(deleteIconX - iconSize, deleteIconY - iconSize);
                ctx.lineTo(deleteIconX + iconSize, deleteIconY + iconSize);
                ctx.moveTo(deleteIconX + iconSize, deleteIconY - iconSize);
                ctx.lineTo(deleteIconX - iconSize, deleteIconY + iconSize);
                ctx.strokeStyle = '#6B7280';
                ctx.lineWidth = 2;
                ctx.stroke();
                if (isLink) {
                    const linkIconX = noteX + this.width - 12;
                    const linkIconY = noteY + this.height - 12;
                    ctx.strokeStyle = COLORS.link;
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(linkIconX, linkIconY, 6, 6);
                    ctx.beginPath();
                    ctx.moveTo(linkIconX + 3, linkIconY);
                    ctx.lineTo(linkIconX + 9, linkIconY - 6);
                    ctx.moveTo(linkIconX + 4, linkIconY - 6);
                    ctx.lineTo(linkIconX + 9, linkIconY - 6);
                    ctx.lineTo(linkIconX + 9, linkIconY - 1);
                    ctx.stroke();
                }
                
                const resizeHandleX = noteX + this.width;
                const resizeHandleY = noteY + this.height;
                ctx.fillStyle = '#9CA3AF';
                ctx.beginPath();
                ctx.moveTo(resizeHandleX, resizeHandleY - 10);
                ctx.lineTo(resizeHandleX - 10, resizeHandleY);
                ctx.lineTo(resizeHandleX, resizeHandleY);
                ctx.closePath();
                ctx.fill();
            }
            
            isBodyClicked(mouseX, mouseY, parentPoint) {
                const noteX = parentPoint.x + this.offsetX;
                const noteY = parentPoint.y + this.offsetY;
                return mouseX > noteX && mouseX < noteX + this.width &&
                       mouseY > noteY && mouseY < noteY + this.height;
            }
            isDeleteClicked(mouseX, mouseY, parentPoint) {
                const noteX = parentPoint.x + this.offsetX;
                const noteY = parentPoint.y + this.offsetY;
                const deleteIconX = noteX + this.width - 10;
                const deleteIconY = noteY + 10;
                const hitArea = 10;
                return mouseX > deleteIconX - hitArea && mouseX < deleteIconX + hitArea &&
                       mouseY > deleteIconY - hitArea && mouseY < deleteIconY + hitArea;
            }
            
            isLinkIconClicked(mouseX, mouseY, parentPoint) {
                const noteX = parentPoint.x + this.offsetX;
                const noteY = parentPoint.y + this.offsetY;
                const linkIconX = noteX + this.width - 12;
                const linkIconY = noteY + this.height - 12;
                const hitArea = 12;
                return mouseX > linkIconX - hitArea && mouseX < linkIconX + hitArea &&
                       mouseY > linkIconY - hitArea && mouseY < linkIconY + hitArea;
            }
            isResizeClicked(mouseX, mouseY, parentPoint) {
                const noteX = parentPoint.x + this.offsetX;
                const noteY = parentPoint.y + this.offsetY;
                const resizeHandleX = noteX + this.width;
                const resizeHandleY = noteY + this.height;
                const hitArea = 15;
                return mouseX > resizeHandleX - hitArea && mouseX < resizeHandleX + hitArea &&
                       mouseY > resizeHandleY - hitArea && mouseY < resizeHandleY + hitArea;
            }
        }
        
        // --- CORE DRAWING FUNCTIONS ---
        function resizeCanvas() {
            canvas.width = parentContainer.clientWidth;
            canvas.height = parentContainer.clientHeight;
            draw();
        }

        function draw() {
            if (!ctx) return;
            
            ctx.save();
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(view.zoom, view.zoom);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            ctx.translate(-view.x, -view.y);
            
            snakes.forEach(snakeObj => {
                if (snakeObj.path && snakeObj.path.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(snakeObj.path[0].x, snakeObj.path[0].y);
                    for (let i = 1; i < snakeObj.path.length; i++) {
                        ctx.lineTo(snakeObj.path[i].x, snakeObj.path[i].y);
                    }
                    ctx.strokeStyle = COLORS.line;
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
            });
            
            notes.forEach(note => {
                const parentPoint = points.find(p => p.id === note.attachedPointId);
                if (parentPoint) note.draw(parentPoint);
            });
            
            points.forEach(p => {
                let angle = 0;
                const ownerSnake = snakes.find(s => s.path && s.path.some(sp => sp.id === p.id));
                if (p.type === 'head' && ownerSnake && ownerSnake.path.length > 1) {
                    const nextPoint = ownerSnake.path[1];
                    angle = Math.atan2(nextPoint.y - p.y, nextPoint.x - p.x);
                }
                p.draw(angle);
            });
            
            snakes.forEach(snakeObj => {
                if (snakeObj.path && snakeObj.path.length > 0) {
                    const head = snakeObj.path[0];
                    ctx.fillStyle = COLORS.text;
                    ctx.font = LABEL_FONT;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(snakeObj.name, head.x, head.y - POINT_RADIUS - 5);
                }
            });

            ctx.restore();
        }

        function getPointAt(worldX, worldY) {
            for (let i = points.length - 1; i >= 0; i--) {
                if (points[i].isClicked(worldX, worldY)) return points[i];
            }
            return null;
        }

        // --- EVENT HANDLERS ---
        function handleMouseDown(e) {
            e.preventDefault();
            potentialDrag = null;
            if (e.button !== 0) return;

            const worldCoords = screenToWorld(e.offsetX, e.offsetY);
            mouseDownCoords = worldCoords;

            for (let i = notes.length - 1; i >= 0; i--) {
                const note = notes[i];
                const parentPoint = points.find(p => p.id === note.attachedPointId);
                if (parentPoint) {
                    if (note.isDeleteClicked(worldCoords.x, worldCoords.y, parentPoint)) {
                        deleteDoc(doc(notesCollection, note.id));
                        mouseDownCoords = null; 
                        return;
                    }
                    if (note.isResizeClicked(worldCoords.x, worldCoords.y, parentPoint)) {
                        potentialDrag = { type: 'note-resize', target: note };
                        note.originalWidth = note.width;
                        note.originalHeight = note.height;
                        canvas.style.cursor = 'nwse-resize';
                        return;
                    }
                    if (isValidUrl(note.text) && note.isLinkIconClicked(worldCoords.x, worldCoords.y, parentPoint)) {
                        window.open(note.text, '_blank');
                        mouseDownCoords = null;
                        return;
                    }
                    if (note.isBodyClicked(worldCoords.x, worldCoords.y, parentPoint)) {
                        potentialDrag = { type: 'note-drag', target: note };
                        note.originalOffsetX = note.offsetX;
                        note.originalOffsetY = note.offsetY;
                        canvas.style.cursor = 'grabbing';
                        return;
                    }
                }
            }

            const clickedPoint = getPointAt(worldCoords.x, worldCoords.y);
            if (clickedPoint) {
                potentialDrag = { type: 'point', target: clickedPoint };
                canvas.style.cursor = 'grabbing';
                return;
            }

            for (let i = snakes.length - 1; i >= 0; i--) {
                const snake = snakes[i];
                if (!snake.path || snake.path.length === 0) continue;
                const head = snake.path[0];
                ctx.font = LABEL_FONT;
                const metrics = ctx.measureText(snake.name);
                const labelX = head.x - metrics.width / 2;
                const labelY = head.y - POINT_RADIUS - 5 - LABEL_HEIGHT;
                if (worldCoords.x > labelX && worldCoords.x < labelX + metrics.width && worldCoords.y > labelY && worldCoords.y < labelY + LABEL_HEIGHT) {
                    potentialDrag = { type: 'snake-drag', target: snake };
                    snake.path.forEach(p => { p.originalX = p.x; p.originalY = p.y; });
                    canvas.style.cursor = 'move';
                    return;
                }
            }
            
            potentialDrag = { type: 'pan' };
            panStart = { x: e.clientX, y: e.clientY };
            canvas.style.cursor = 'grabbing';
        }
        
        function handleMouseMove(e) {
            e.preventDefault();

            if (isDraggingPoint || isDraggingSnake || isResizingNote || isDraggingNote || isPanning) {
                const worldCoords = screenToWorld(e.offsetX, e.offsetY);
                const mouseX = worldCoords.x;
                const mouseY = worldCoords.y;

                if (isPanning) {
                    const dx = e.clientX - panStart.x;
                    const dy = e.clientY - panStart.y;
                    view.x -= dx / view.zoom;
                    view.y -= dy / view.zoom;
                    panStart = { x: e.clientX, y: e.clientY };
                    draw();
                } else if (isResizingNote && resizedNote) {
                    const deltaX = mouseX - mouseDownCoords.x;
                    const deltaY = mouseY - mouseDownCoords.y;
                    resizedNote.width = Math.max(MIN_NOTE_WIDTH, resizedNote.originalWidth + deltaX);
                    resizedNote.height = Math.max(MIN_NOTE_HEIGHT, resizedNote.originalHeight + deltaY);
                    draw();
                } else if (isDraggingNote && draggedNote) {
                    const deltaX = mouseX - mouseDownCoords.x;
                    const deltaY = mouseY - mouseDownCoords.y;
                    draggedNote.offsetX = draggedNote.originalOffsetX + deltaX;
                    draggedNote.offsetY = draggedNote.originalOffsetY + deltaY;
                    draw();
                } else if (isDraggingPoint && draggedPoint) {
                    let currentX = mouseX, currentY = mouseY;
                    let ownerSnake = null, pointIndexInSnake = -1;
                    for (const snake of snakes) {
                        if(!snake.path) continue;
                        const index = snake.path.findIndex(p => p.id === draggedPoint.id);
                        if (index > -1) {
                            ownerSnake = snake; pointIndexInSnake = index; break;
                        }
                    }
                    if (ownerSnake) {
                        const ownerSnakePath = ownerSnake.path;
                        const prev = ownerSnakePath[pointIndexInSnake - 1], next = ownerSnakePath[pointIndexInSnake + 1];
                        if (prev) {
                            const dist = Math.hypot(currentX - prev.x, currentY - prev.y);
                            if (dist > STRETCH_LIMIT) {
                                const angle = Math.atan2(currentY - prev.y, currentX - prev.x);
                                currentX = prev.x + STRETCH_LIMIT * Math.cos(angle);
                                currentY = prev.y + STRETCH_LIMIT * Math.sin(angle);
                            }
                        }
                        if (next) {
                            const dist = Math.hypot(currentX - next.x, currentY - next.y);
                            if (dist > STRETCH_LIMIT) {
                                const angle = Math.atan2(currentY - next.y, currentX - next.x);
                                currentX = next.x + STRETCH_LIMIT * Math.cos(angle);
                                currentY = next.y + STRETCH_LIMIT * Math.sin(angle);
                            }
                        }
                    }
                    draggedPoint.x = currentX;
                    draggedPoint.y = currentY;
                    draw();
                } else if (isDraggingSnake && draggedSnake) {
                    const deltaX = mouseX - mouseDownCoords.x;
                    const deltaY = mouseY - mouseDownCoords.y;
                    draggedSnake.path.forEach(p => { p.x = p.originalX + deltaX; p.y = p.originalY + deltaY; });
                    draw();
                }
                return;
            }

            if (potentialDrag && mouseDownCoords) {
                const worldCoords = screenToWorld(e.offsetX, e.offsetY);
                const dist = Math.hypot(worldCoords.x - mouseDownCoords.x, worldCoords.y - mouseDownCoords.y);

                if (dist > DRAG_THRESHOLD) {
                    switch (potentialDrag.type) {
                        case 'point': isDraggingPoint = true; draggedPoint = potentialDrag.target; break;
                        case 'note-resize': isResizingNote = true; resizedNote = potentialDrag.target; break;
                        case 'note-drag': isDraggingNote = true; draggedNote = potentialDrag.target; break;
                        case 'snake-drag': isDraggingSnake = true; draggedSnake = potentialDrag.target; break;
                        case 'pan': isPanning = true; break;
                    }
                    potentialDrag = null;
                }
            }
        }

        function handleMouseUp(e) {
            e.preventDefault();
            if (isDraggingPoint && draggedPoint) {
                updateDoc(doc(pointsCollection, draggedPoint.id), { x: draggedPoint.x, y: draggedPoint.y });
            }
            if (isDraggingSnake && draggedSnake) {
                const batch = writeBatch(db);
                draggedSnake.path.forEach(p => {
                    const pointRef = doc(pointsCollection, p.id);
                    batch.update(pointRef, { x: p.x, y: p.y });
                });
                batch.commit();
            }
            if (isResizingNote && resizedNote) {
                updateDoc(doc(notesCollection, resizedNote.id), { width: resizedNote.width, height: resizedNote.height });
            }
            if (isDraggingNote && draggedNote) {
                updateDoc(doc(notesCollection, draggedNote.id), { offsetX: draggedNote.offsetX, offsetY: draggedNote.offsetY });
            }

            isDraggingPoint = isDraggingSnake = isResizingNote = isPanning = isDraggingNote = false;
            draggedPoint = draggedSnake = resizedNote = draggedNote = null;
            potentialDrag = null;
            mouseDownCoords = null;
            canvas.style.cursor = 'grab';
        }

        async function handleContextMenu(e) {
            e.preventDefault();
            const worldCoords = screenToWorld(e.offsetX, e.offsetY);
            const clickedPoint = getPointAt(worldCoords.x, worldCoords.y);
            if(clickedPoint) {
                const existingNote = notes.find(n => n.attachedPointId === clickedPoint.id);
                if(existingNote){
                    createNoteInput(existingNote);
                } else {
                    const newNoteData = {
                        text: "Type something...", attachedPointId: clickedPoint.id,
                        width: 160, height: 100, offsetX: 40, offsetY: -50,
                    };
                    try {
                        const docRef = await addDoc(notesCollection, newNoteData);
                        const tempNote = new Note(newNoteData.text, newNoteData.attachedPointId);
                        tempNote.id = docRef.id;
                        createNoteInput(tempNote);
                    } catch (error) {
                        console.error("Error creating note:", error);
                    }
                }
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const mousePos = { x: e.offsetX, y: e.offsetY };
            const worldPosBeforeZoom = screenToWorld(mousePos.x, mousePos.y);
            
            const zoomFactor = 1.1;
            let newZoom = view.zoom;
            if (e.deltaY < 0) {
                newZoom *= zoomFactor;
            } else {
                newZoom /= zoomFactor;
            }
            view.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

            const worldPosAfterZoom = screenToWorld(mousePos.x, mousePos.y);

            view.x += worldPosBeforeZoom.x - worldPosAfterZoom.x;
            view.y += worldPosBeforeZoom.y - worldPosAfterZoom.y;

            draw();
        }
        
        function handleDoubleClick(e) {
            e.preventDefault();
            if (e.target !== canvas) return;

            const worldCoords = screenToWorld(e.offsetX, e.offsetY);
            const mouseX = worldCoords.x;
            const mouseY = worldCoords.y;

            for (let i = notes.length - 1; i >= 0; i--) {
                const note = notes[i];
                const parentPoint = points.find(p => p.id === note.attachedPointId);
                if (parentPoint && note.isBodyClicked(mouseX, mouseY, parentPoint)) {
                    createNoteInput(note);
                    return; 
                }
            }
        }

        // --- UI/CONTROL LOGIC ---
        function toggleTheme() {
            if (currentTheme === 'light') {
                currentTheme = 'dark';
                COLORS = DARK_THEME;
                document.documentElement.classList.add('dark');
            } else {
                currentTheme = 'light';
                COLORS = LIGHT_THEME;
                document.documentElement.classList.remove('dark');
            }
            draw();
        }

        function showConfirmationModal(message, onConfirm) {
            document.getElementById('confirmation-modal-overlay')?.remove();
            const overlay = document.createElement('div');
            overlay.id = 'confirmation-modal-overlay';
            overlay.className = 'fixed inset-0 bg-black/60 z-40 flex items-center justify-center p-4';
            const panel = document.createElement('div');
            panel.className = 'modal-panel bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm transform opacity-0 translate-y-4';
            const text = document.createElement('p');
            text.className = 'text-gray-800 dark:text-gray-200 mb-6 text-lg';
            text.textContent = message;
            const btnContainer = document.createElement('div');
            btnContainer.className = 'flex justify-end space-x-3';
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'px-5 py-2 bg-gray-200 text-gray-800 font-semibold rounded-md hover:bg-gray-300 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400';
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'Clear Board';
            confirmBtn.className = 'px-5 py-2 bg-red-500 text-white font-semibold rounded-md hover:bg-red-600 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400';
            btnContainer.append(cancelBtn, confirmBtn);
            panel.append(text, btnContainer);
            overlay.appendChild(panel);
            document.body.appendChild(overlay);
            setTimeout(() => {
                panel.classList.remove('opacity-0', 'translate-y-4');
                panel.classList.add('opacity-100', 'translate-y-0');
            }, 10);
            const closeModal = () => {
                panel.classList.add('opacity-0');
                setTimeout(() => overlay.remove(), 200);
            };
            cancelBtn.addEventListener('click', closeModal);
            confirmBtn.addEventListener('click', () => {
                onConfirm();
                closeModal();
            });
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closeModal();
            });
        }

        function createNoteInput(note) {
            document.getElementById('note-editor')?.remove();
            const parentPoint = points.find(p => p.id === note.attachedPointId);
            if (!parentPoint) return;

            const screenPos = worldToScreen(parentPoint.x + note.offsetX, parentPoint.y + note.offsetY);
            const screenWidth = note.width * view.zoom;
            const screenHeight = note.height * view.zoom;

            const textarea = document.createElement('textarea');
            textarea.id = 'note-editor';
            textarea.value = note.text === "Type something..." ? "" : note.text;
            textarea.style.position = 'absolute';
            textarea.style.left = `${canvas.offsetLeft + screenPos.x}px`;
            textarea.style.top = `${canvas.offsetTop + screenPos.y}px`;
            textarea.style.width = `${screenWidth}px`;
            textarea.style.height = `${screenHeight}px`;
            textarea.style.zIndex = '30';
            textarea.className = 'p-2 border-2 border-blue-500 rounded-md shadow-lg focus:outline-none bg-yellow-50 dark:bg-yellow-900/80 dark:text-white';
            parentContainer.appendChild(textarea);
            textarea.focus();
            textarea.select();
            const finishEditing = () => {
                if(document.body.contains(textarea)) {
                    const newText = textarea.value.trim() === '' ? 'Type something...' : textarea.value;
                    if (note.text !== newText) {
                        updateDoc(doc(notesCollection, note.id), { text: newText });
                    }
                    parentContainer.removeChild(textarea);
                }
            };
            textarea.addEventListener('blur', finishEditing);
            textarea.addEventListener('keydown', e => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); finishEditing(); } 
                else if (e.key === 'Escape') { finishEditing(); }
            });
        }

        async function removeSnake(snakeId) {
            const snakeToRemove = snakes.find(s => s.id === snakeId);
            if (!snakeToRemove || !snakeToRemove.path) return;
            const batch = writeBatch(db);
            batch.delete(doc(snakesCollection, snakeId));
            const pointIdsToRemove = new Set(snakeToRemove.path.map(p => p.id));
            pointIdsToRemove.forEach(pointId => {
                batch.delete(doc(pointsCollection, pointId));
            });
            const notesSnapshot = await getDocs(notesCollection);
            notesSnapshot.forEach(noteDoc => {
                if (pointIdsToRemove.has(noteDoc.data().attachedPointId)) {
                    batch.delete(noteDoc.ref);
                }
            });
            await batch.commit();
        }
        
        async function addBodyPointToSnake(snakeId) {
            const snake = snakes.find(s => s.id === snakeId);
            if (!snake || !snake.path || snake.path.length < 2) return;
            const beforeTail = snake.path[snake.path.length - 2];
            const tail = snake.path[snake.path.length - 1];
            const newPointData = {
                x: (beforeTail.x + tail.x) / 2,
                y: (beforeTail.y + tail.y) / 2,
                type: 'body'
            };
            const newPointRef = await addDoc(pointsCollection, newPointData);
            const newPathArray = snake.path.map(p => p.id);
            newPathArray.splice(newPathArray.length - 1, 0, newPointRef.id);
            await updateDoc(doc(snakesCollection, snakeId), { path: newPathArray });
        }

        function showRenameInput(menuContainer) {
            const snakeId = menuContainer.dataset.id;
            const snake = snakes.find(s => s.id === snakeId);
            const toggleButton = menuContainer.querySelector('button');
            const dropdownContent = menuContainer.querySelector('.dropdown-content');
            dropdownContent.classList.add('hidden');
            toggleButton.style.display = 'none';
            const input = document.createElement('input');
            input.type = 'text';
            input.value = snake.name;
            input.className = 'w-full px-3 py-2 bg-white dark:bg-gray-600 border border-blue-400 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400';
            menuContainer.insertBefore(input, toggleButton);
            input.focus();
            input.select();
            const finishRename = () => {
                const newName = input.value.trim();
                if (newName && newName !== snake.name) {
                    updateDoc(doc(snakesCollection, snakeId), { name: newName });
                }
                menuContainer.removeChild(input);
                toggleButton.style.display = 'block';
            };
            input.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === 'Escape') finishRename(); });
            input.addEventListener('blur', finishRename);
        }

        function createSnakeDropdownMenu(snake) {
            const menuContainer = document.createElement('div');
            menuContainer.className = 'relative snake-menu';
            menuContainer.dataset.id = snake.id;
            const toggleButton = document.createElement('button');
            toggleButton.innerHTML = `${snake.name} Actions <span class="text-xs">▼</span>`;
            toggleButton.className = 'w-full text-left px-3 py-2 bg-gray-200 text-gray-800 font-semibold rounded-md hover:bg-gray-300 transition-colors shadow-sm focus:outline-none focus:ring-2 focus:ring-gray-400';
            const dropdownContent = document.createElement('div');
            dropdownContent.className = 'dropdown-content absolute left-0 right-0 mt-1 bg-white border rounded-md shadow-lg p-2 space-y-1 hidden z-10';
            dropdownContent.innerHTML = `<button data-action="rename" class="w-full text-left px-3 py-1.5 text-sm text-gray-700 hover:bg-gray-100 rounded-md">Rename</button><button data-action="add-body" class="w-full text-left px-3 py-1.5 text-sm text-sky-700 hover:bg-sky-50 rounded-md">Add Body Point</button><div class="border-t my-1 dark:border-gray-600"></div><button data-action="remove" class="w-full text-left px-3 py-1.5 text-sm text-red-700 hover:bg-red-50 rounded-md">Remove Snake</button>`;
            menuContainer.append(toggleButton, dropdownContent);
            snakeControlsContainer.appendChild(menuContainer);
        }

        snakeControlsContainer.addEventListener('click', e => {
            const button = e.target.closest('button');
            if (!button) return;
            const menuContainer = e.target.closest('.snake-menu');
            if (!menuContainer) return;
            if (button === menuContainer.querySelector('button')) {
                menuContainer.querySelector('.dropdown-content').classList.toggle('hidden');
                return;
            }
            const action = button.dataset.action;
            if (action) {
                const snakeId = menuContainer.dataset.id;
                if (action === 'rename') showRenameInput(menuContainer);
                else if (action === 'add-body') addBodyPointToSnake(snakeId);
                else if (action === 'remove') removeSnake(snakeId);
            }
        });

        createSnakeBtn.addEventListener('click', async () => {
            const batch = writeBatch(db);
            
            const startX = view.x + (canvas.width / 2 / view.zoom);
            const startY = view.y + (canvas.height / 2 / view.zoom);
            
            const headData = { x: startX, y: startY - 100, type: 'head' };
            const bodyData = { x: startX, y: startY, type: 'body' };
            const tailData = { x: startX, y: startY + 100, type: 'tail' };
            
            const headRef = doc(collection(db, pointsCollection.path));
            const bodyRef = doc(collection(db, pointsCollection.path));
            const tailRef = doc(collection(db, pointsCollection.path));

            batch.set(headRef, headData);
            batch.set(bodyRef, bodyData);
            batch.set(tailRef, tailData);
            
            const snakeData = {
                name: `Snake ${snakes.length + 1}`,
                path: [headRef.id, bodyRef.id, tailRef.id]
            };
            const snakeRef = doc(collection(db, snakesCollection.path));
            batch.set(snakeRef, snakeData);

            await batch.commit();
        });

        async function clearCollection(collectionRef) {
             const batch = writeBatch(db);
             const snapshot = await getDocs(collectionRef);
             snapshot.forEach(doc => batch.delete(doc.ref));
             await batch.commit();
        }

        clearBoardBtn.addEventListener('click', () => {
            if (document.getElementById('note-editor') || document.getElementById('confirmation-modal-overlay')) return;
            showConfirmationModal('Are you sure you want to clear the entire board?', async () => {
                await Promise.all([
                    clearCollection(snakesCollection),
                    clearCollection(pointsCollection),
                    clearCollection(notesCollection),
                    setDoc(noteBoxDocRef, { content: '' })
                ]);
            });
        });

        // --- INITIALIZATION ---
        async function initFirebase() {
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

            if (!firebaseConfig.apiKey) {
                userInfoDiv.textContent = 'Firebase config not found.';
                console.error("Firebase config not found. Please provide it.");
                return;
            }

            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            setLogLevel('error');

            const publicDataPath = `/artifacts/${appId}/public/data`;
            snakesCollection = collection(db, `${publicDataPath}/snakes`);
            pointsCollection = collection(db, `${publicDataPath}/points`);
            notesCollection = collection(db, `${publicDataPath}/notes`);
            noteBoxDocRef = doc(db, `${publicDataPath}/noteBox/mainNote`);

            onAuthStateChanged(auth, user => {
                if (user) {
                    userInfoDiv.innerHTML = `<strong>Your ID:</strong> ${user.uid}`;
                    setupRealtimeListeners();
                } else {
                     userInfoDiv.textContent = 'Authenticating...';
                }
            });

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed:", error);
                userInfoDiv.textContent = 'Authentication failed.';
            }
        }
        
        function processAndDraw(localSnakes, localPoints, localNotes) {
            points = localPoints.map(pData => {
                const point = new Point(pData.x, pData.y, pData.type);
                point.id = pData.id;
                return point;
            });

            notes = localNotes.map(nData => {
              const note = new Note(nData.text, nData.attachedPointId);
              note.id = nData.id;
              note.width = nData.width;
              note.height = nData.height;
              note.offsetX = nData.offsetX;
              note.offsetY = nData.offsetY;
              return note;
            });

            const pointMap = new Map(points.map(p => [p.id, p]));
            
            snakes = localSnakes.map(sData => {
                const snake = { ...sData };
                snake.path = sData.path ? sData.path.map(pointId => pointMap.get(pointId)).filter(p => p) : [];
                return snake;
            });
            
            snakeControlsContainer.innerHTML = '';
            if (snakes.length > 0) {
                 snakeControlsContainer.classList.add('pt-2', 'border-t', 'dark:border-gray-700');
                 snakes.forEach(createSnakeDropdownMenu);
            } else {
                 snakeControlsContainer.classList.remove('pt-2', 'border-t', 'dark:border-gray-700');
            }

            draw();
        }

        function setupRealtimeListeners() {
            let localSnakes = [];
            let localPoints = [];
            let localNotes = [];
            
            onSnapshot(snakesCollection, (snapshot) => {
                localSnakes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                processAndDraw(localSnakes, localPoints, localNotes);
            }, (error) => console.error("Error listening to snakes:", error));

            onSnapshot(pointsCollection, (snapshot) => {
                localPoints = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                processAndDraw(localSnakes, localPoints, localNotes);
            }, (error) => console.error("Error listening to points:", error));
            
            onSnapshot(notesCollection, (snapshot) => {
                localNotes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                processAndDraw(localSnakes, localPoints, localNotes);
            }, (error) => console.error("Error listening to notes:", error));

            onSnapshot(noteBoxDocRef, (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    if (noteBoxInput.value !== data.content) {
                        noteBoxInput.value = data.content || '';
                    }
                }
            }, (error) => console.error("Error listening to note box:", error));
        }

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseout', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('contextmenu', handleContextMenu);
            canvas.addEventListener('dblclick', handleDoubleClick);
            
            toggleThemeBtn.addEventListener('click', toggleTheme);
            
            const saveNoteBox = debounce(() => {
                setDoc(noteBoxDocRef, { content: noteBoxInput.value }, { merge: true });
            }, 500);
            noteBoxInput.addEventListener('input', saveNoteBox);

            initFirebase();
        }

        init();
    </script>
</body>
</html>
